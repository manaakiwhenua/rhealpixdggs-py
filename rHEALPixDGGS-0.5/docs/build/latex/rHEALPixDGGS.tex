% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12ptopenany,oneside]{sphinxmanual}
\usepackage[utf8x]{inputenc}

\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{xifthen}    % provides \isempty test
\newcommand{\del}{\partial}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\reals}{\mathbb{R}}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\cat}{\,\,\widehat{}\,\,}
\newcommand{\phat}{\hat{p}}
\newcommand{\hhat}{\hat{h}}
\newcommand{\Hhat}{\hat{H}}
\newcommand{\rh}{\underline{h}}
\newcommand{\rhhat}{\hat{\rh}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\maxlevel}{L}
\newcommand{\llt}{<_\text{lex}}
\newcommand{\tge}{\trianglerighteq}
\newcommand{\tle}{\trianglelefteq}
\newcommand{\tlt}{\triangleleft}
\newcommand{\nam}{\mathop{\mathrm{name}}}
\newcommand{\cell}[1][]{
  \ifthenelse{\isempty{#1}}
    {\square}   % if #1 is empty
    {\boxed{#1}}  % if #1 is not empty
}
%\newcommand{\cell}[1]{\boxed{#1}}
\newcommand{\ind}{\mathop{\mathrm{index}}}
\newcommand{\bind}{\mathop{\mathrm{Index}}}
\newcommand{\val}{\mathop{\mathrm{value_9}}}
\newcommand{\loc}{\mathop{\mathrm{location}}}

\title{rHEALPixDGGS Documentation}
\date{July 26, 2013}
\release{0.5}
\author{Alexander Raichev}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{introduction:introduction}\label{introduction:welcome-to-scenzgrid-dggs-s-documentation}\label{introduction::doc}
rHEALPixDGGS is a Python 3.3 package that implements the rHEALPix discrete global grid system (DGGS).
This documentation assumes you are familiar with the rHEALPix DGGS as described in {\hyperref[introduction:grs2013]{{[}GRS2013{]}}} and familiar with basic Python 3.3 usage as described in \href{http://docs.python.org/3/tutorial/}{The Python Tutorial}.


\section{Requirements}
\label{introduction:requirements}\begin{itemize}
\item {} 
\href{http://python.org/}{Python \textgreater{}=3.3}

\item {} 
\href{http://www.numpy.org/}{NumPy \textgreater{}=1.7} Base N-dimensional array package

\item {} 
\href{http://www.scipy.org/}{SciPy \textgreater{}=0.12} Fundamental library for scientific computing

\item {} 
\href{http://matplotlib.org/}{Matplotlib \textgreater{}=1.2.1} Comprehensive 2D Plotting

\item {} 
\href{http://code.google.com/p/pyproj/}{Pyproj \textgreater{}=1.9.3}
Python interface to the PROJ.4 cartographic library

\item {} 
\href{http://www.sagemath.org}{Sage \textgreater{}=5.10}
(Optional) Comprehensive mathematics package.
Needed only for a few optional graphics methods.
To use the optional graphics methods, start a Sage notebook session and import/attach the Python module that contains the methods.
For examples, see the Sage worksheet \code{rhealpix\_dggs/tests/test\_rhealpix\_dggs.sws}.

\end{itemize}


\section{Installation}
\label{introduction:installation}
rHEALPixDGGS is available for download at Landcare Research's git repository \href{http://code.scenzgrid.org/index.php/p/scenzgrid-py/source/tree/master/rHEALPixDGGS-0.5}{http://code.scenzgrid.org/index.php/p/scenzgrid-py/source/tree/master/rHEALPixDGGS-0.5} and can be cloned via the command \code{git clone git@code.scenzgrid.org:scenzgrid-py.git}.

To install Sage, download and install the appropriate binary file from \href{http://www.sagemath.org}{sagemath.org}.
Then install Pyproj within Sage by downloading the Pyproj source, changing to the Pyproj directory, starting a Sage shell via \code{sage -sh}, then typing \code{python setup.py build}, then \code{python setup.py install}.
If that doesn't work, try again but first start in superuser mode via \code{sudo su}.


\section{Usage}
\label{introduction:usage}
To use rHEALPixDGGS after installing it, start a Python session in the directory where you downloaded the modules and import the modules.
Here are some examples.
For a list of all methods available, see the application programming interface (API) in the following chapters.


\subsection{Using the \texttt{projection\_wrapper} Module}
\label{introduction:using-the-projection-wrapper-module}
The module \code{projection\_wrapper} implements a wrapper for map projections of ellipsoids of revolution (which include spheres but not general triaxial ellipsoids) defined in \code{pj\_healpix}, \code{pj\_rhealpix}, and Pyproj.
For brevity hereafter, the word `ellipsoid' abbreviates `ellipsoid of revolution'.

Currently \code{projection\_wrapper} uses the HEALPix and rHEALPix projections
defined in \code{pj\_healpix} and \code{pj\_rhealpix} and \emph{not} the buggy versions  defined in Pyproj 1.9.3 as \code{PJ\_healpix.c}.
Alternatively, you can download a corrected version of \code{PJ\_healpix.c} from
\href{http://trac.osgeo.org/proj/changeset/2378}{trac.osgeo.org/proj/changeset/2378}, rebuild Pyproj with it, and use it in \code{rhealpix\_dggs} by editing the \code{HOMEMADE\_PROJECTIONS} line in \code{projection\_wrapper}.

Import all the classes, methods, and constants from the module:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{projection\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

Create an ellipsoid, say, one with major radius 5 and eccentricity 0.8:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ellps\PYGZus{}1} \PYG{o}{=} \PYG{n}{Ellipsoid}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{ellps\PYGZus{}1}\PYG{p}{)}
\PYG{g+go}{ellipsoid:}
\PYG{g+go}{    R\PYGZus{}A = 4.32200117119}
\PYG{g+go}{    a = 5}
\PYG{g+go}{    b = 3.0}
\PYG{g+go}{    e = 0.8}
\PYG{g+go}{    f = 0.4}
\PYG{g+go}{    lat\PYGZus{}0 = 0}
\PYG{g+go}{    lon\PYGZus{}0 = 0}
\PYG{g+go}{    radians = False}
\PYG{g+go}{    sphere = False}
\end{Verbatim}

The names of the ellipsoid attributes agree with the names of the \href{http://trac.osgeo.org/proj/wiki/GenParms}{PROJ.4 ellipsoid parameters}.

By default, angles are measured in degrees.
If you prefer radians, then do:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ellps\PYGZus{}2} \PYG{o}{=} \PYG{n}{Ellipsoid}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{ellps\PYGZus{}2}\PYG{p}{)}
\PYG{g+go}{ellipsoid:}
\PYG{g+go}{    R\PYGZus{}A = 4.32200117119}
\PYG{g+go}{    a = 5}
\PYG{g+go}{    b = 3.0}
\PYG{g+go}{    e = 0.8}
\PYG{g+go}{    f = 0.4}
\PYG{g+go}{    lat\PYGZus{}0 = 0}
\PYG{g+go}{    lon\PYGZus{}0 = 0}
\PYG{g+go}{    radians = True}
\PYG{g+go}{    sphere = False}
\end{Verbatim}

Some common ellipsoids are predefined as constants.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{UNIT\PYGZus{}SPHERE}\PYG{p}{)}
\PYG{g+go}{ellipsoid:}
\PYG{g+go}{    R = 1}
\PYG{g+go}{    R\PYGZus{}A = 1}
\PYG{g+go}{    a = 1}
\PYG{g+go}{    b = 1}
\PYG{g+go}{    e = 0}
\PYG{g+go}{    f = 0}
\PYG{g+go}{    lat\PYGZus{}0 = 0}
\PYG{g+go}{    lon\PYGZus{}0 = 0}
\PYG{g+go}{    radians = False}
\PYG{g+go}{    sphere = True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{WGS84\PYGZus{}ELLIPSOID}\PYG{p}{)}
\PYG{g+go}{ellipsoid:}
\PYG{g+go}{    R\PYGZus{}A = 6374581.4671}
\PYG{g+go}{    a = 6378137.0}
\PYG{g+go}{    b = 6356752.31414}
\PYG{g+go}{    e = 0.0578063088401}
\PYG{g+go}{    f = 0.00335281068118}
\PYG{g+go}{    lat\PYGZus{}0 = 0}
\PYG{g+go}{    lon\PYGZus{}0 = 0}
\PYG{g+go}{    radians = False}
\PYG{g+go}{    sphere = False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}\PYG{p}{)}
\PYG{g+go}{ellipsoid:}
\PYG{g+go}{    R\PYGZus{}A = 6374581.4671}
\PYG{g+go}{    a = 6378137.0}
\PYG{g+go}{    b = 6356752.31414}
\PYG{g+go}{    e = 0.0578063088401}
\PYG{g+go}{    f = 0.00335281068118}
\PYG{g+go}{    lat\PYGZus{}0 = 0}
\PYG{g+go}{    lon\PYGZus{}0 = 0}
\PYG{g+go}{    radians = True}
\PYG{g+go}{    sphere = False}
\end{Verbatim}

Ellipsoid instances are parametrized by geographic longitude and latitude with the central meridian at \code{lon\_0} and the parallel of origin at \code{lat\_0}.

Project some points of the ellipsoid using the HEALPix and rHEALPix projections:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellps\PYGZus{}1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{healpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rh} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellps\PYGZus{}1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rhealpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.0, 3.351278550178026)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rh}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.0, 3.351278550178026)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.864006732389895, 4.2584985144432679)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rh}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}0.86400673238989445, 4.2584985144432679)}
\end{Verbatim}


\subsection{Using the \texttt{rhealpix\_dggs} Module}
\label{introduction:using-the-rhealpix-dggs-module}
The module \code{rhealpix\_dggs} implements the rHEALPix DGGS and various operations thereupon.

Import all the classes, methods, and constants from the module

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{rhealpix\PYGZus{}dggs} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

Create the (0, 0)-rHEALPix DGGS with N\_side=3 that is based upon the WGS84 ellipsoid:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}ELLIPSOID}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{E}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{N\PYGZus{}side}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{)}
\PYG{g+go}{rHEALPix DGGS:}
\PYG{g+go}{    N\PYGZus{}side = 3}
\PYG{g+go}{    north\PYGZus{}square = 0}
\PYG{g+go}{    south\PYGZus{}square = 0}
\PYG{g+go}{    max\PYGZus{}areal\PYGZus{}res = 1}
\PYG{g+go}{    max\PYGZus{}level = 15}
\PYG{g+go}{    ellipsoid:}
\PYG{g+go}{        R\PYGZus{}A = 6374581.4671}
\PYG{g+go}{        a = 6378137.0}
\PYG{g+go}{        b = 6356752.31414}
\PYG{g+go}{        e = 0.0578063088401}
\PYG{g+go}{        f = 0.00335281068118}
\PYG{g+go}{        lat\PYGZus{}0 = 0}
\PYG{g+go}{        lon\PYGZus{}0 = 0}
\PYG{g+go}{        radians = False}
\PYG{g+go}{        sphere = False}
\end{Verbatim}

Some common rHEALPix DGGSs are predefined as constants:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{UNIT\PYGZus{}003}\PYG{p}{)}
\PYG{g+go}{rHEALPix DGGS:}
\PYG{g+go}{    N\PYGZus{}side = 3}
\PYG{g+go}{    north\PYGZus{}square = 0}
\PYG{g+go}{    south\PYGZus{}square = 0}
\PYG{g+go}{    max\PYGZus{}areal\PYGZus{}resolution = 1}
\PYG{g+go}{    max\PYGZus{}resolution = 1}
\PYG{g+go}{    ellipsoid:}
\PYG{g+go}{        R = 1}
\PYG{g+go}{        R\PYGZus{}A = 1}
\PYG{g+go}{        a = 1}
\PYG{g+go}{        b = 1}
\PYG{g+go}{        e = 0}
\PYG{g+go}{        f = 0}
\PYG{g+go}{        lat\PYGZus{}0 = 0}
\PYG{g+go}{        lon\PYGZus{}0 = 0}
\PYG{g+go}{        radians = False}
\PYG{g+go}{        sphere = True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{WGS84\PYGZus{}003}\PYG{p}{)}
\PYG{g+go}{rHEALPix DGGS:}
\PYG{g+go}{    N\PYGZus{}side = 3}
\PYG{g+go}{    north\PYGZus{}square = 0}
\PYG{g+go}{    south\PYGZus{}square = 0}
\PYG{g+go}{    max\PYGZus{}areal\PYGZus{}resolution = 1}
\PYG{g+go}{    max\PYGZus{}resolution = 15}
\PYG{g+go}{    ellipsoid:}
\PYG{g+go}{        R\PYGZus{}A = 6374581.4671}
\PYG{g+go}{        a = 6378137.0}
\PYG{g+go}{        b = 6356752.314140356}
\PYG{g+go}{        e = 0.0578063088401}
\PYG{g+go}{        f = 0.003352810681182319}
\PYG{g+go}{        lat\PYGZus{}0 = 0}
\PYG{g+go}{        lon\PYGZus{}0 = 0}
\PYG{g+go}{        radians = False}
\PYG{g+go}{        sphere = False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{UNIT\PYGZus{}003\PYGZus{}RADIANS}\PYG{p}{)}
\PYG{g+go}{rHEALPix DGGS:}
\PYG{g+go}{    N\PYGZus{}side = 3}
\PYG{g+go}{    north\PYGZus{}square = 0}
\PYG{g+go}{    south\PYGZus{}square = 0}
\PYG{g+go}{    max\PYGZus{}areal\PYGZus{}resolution = 1}
\PYG{g+go}{    max\PYGZus{}resolution = 1}
\PYG{g+go}{    ellipsoid:}
\PYG{g+go}{        R = 1}
\PYG{g+go}{        R\PYGZus{}A = 1}
\PYG{g+go}{        a = 1}
\PYG{g+go}{        b = 1}
\PYG{g+go}{        e = 0}
\PYG{g+go}{        f = 0}
\PYG{g+go}{        lat\PYGZus{}0 = 0}
\PYG{g+go}{        lon\PYGZus{}0 = 0}
\PYG{g+go}{        radians = True}
\PYG{g+go}{        sphere = True}
\end{Verbatim}

Pick a (longitude-latitude) point on the ellipsoid and find the level 1 cell that contains it

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{;} \PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{Q0}
\end{Verbatim}

Find the ellipsoidal (edge) neighbors of this cell

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)}
\PYG{g+go}{west P2}
\PYG{g+go}{east Q1}
\PYG{g+go}{north N2}
\PYG{g+go}{south Q3}
\end{Verbatim}

Find the planar (edge) neighbors of this cell

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{plane}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)}
\PYG{g+go}{down Q3}
\PYG{g+go}{right Q1}
\PYG{g+go}{up N2}
\PYG{g+go}{left P2}
\end{Verbatim}

Find all the level 1 cells intersecting the longitude-latitude aligned ellipsoidal quadrangle with given northwest and southeast corners

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nw} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{se} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cells} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nw}\PYG{p}{,} \PYG{n}{se}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{cells}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N2\PYGZsq{}, \PYGZsq{}N1\PYGZsq{}, \PYGZsq{}N0\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}Q0\PYGZsq{}, \PYGZsq{}Q1\PYGZsq{}, \PYGZsq{}Q2\PYGZsq{}, \PYGZsq{}R0\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}Q3\PYGZsq{}, \PYGZsq{}Q4\PYGZsq{}, \PYGZsq{}Q5\PYGZsq{}, \PYGZsq{}R3\PYGZsq{}]}
\end{Verbatim}

Compute the ellipsoidal shape and ellipsoidal nuclei of these cells

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{cells}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,} \PYG{n}{cell}\PYG{o}{.}\PYG{n}{ellipsoidal\PYGZus{}shape}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cell}\PYG{o}{.}\PYG{n}{nucleus\PYGZus{}and\PYGZus{}vertices}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{N2 dart (5.0888874903416268e\PYGZhy{}14, 58.470677829627355)}
\PYG{g+go}{N1 skew\PYGZus{}quad (45.000000000000036, 58.470677829627355)}
\PYG{g+go}{N0 dart (89.999999999999957, 58.470677829627363)}
\PYG{g+go}{Q0 quad (14.999999999999998, 26.438744923100096)}
\PYG{g+go}{Q1 quad (45.0, 26.438744923100096)}
\PYG{g+go}{Q2 quad (74.999999999999986, 26.438744923100096)}
\PYG{g+go}{R0 quad (105.0, 26.438744923100096)}
\PYG{g+go}{Q3 quad (14.999999999999998, 3.560649871414923e\PYGZhy{}15)}
\PYG{g+go}{Q4 quad (45.0, 3.560649871414923e\PYGZhy{}15)}
\PYG{g+go}{Q5 quad (74.999999999999986, 3.560649871414923e\PYGZhy{}15)}
\PYG{g+go}{R3 quad (105.0, 3.560649871414923e\PYGZhy{}15)}
\end{Verbatim}

Create the (0, 0)-rHEALPix DGGS with N\_side = 3 that is based on the WGS84 ellipsoid.
Orient the DGGS so that the planar origin (0, 0) is on Auckland, New Zealand:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{174}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{37}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Approximate Auckland lon\PYGZhy{}lat coordinates}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{projection\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Ellipsoid}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}A}\PYG{p}{,} \PYG{n}{f}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}F}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{lon\PYGZus{}0}\PYG{o}{=}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lat\PYGZus{}0}\PYG{o}{=}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{n}{N\PYGZus{}side}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{)}
\PYG{g+go}{rHEALPix DGGS:}
\PYG{g+go}{    N\PYGZus{}side = 3}
\PYG{g+go}{    north\PYGZus{}square = 0}
\PYG{g+go}{    south\PYGZus{}square = 0}
\PYG{g+go}{    max\PYGZus{}areal\PYGZus{}res = 1}
\PYG{g+go}{    max\PYGZus{}level = 15}
\PYG{g+go}{    ellipsoid:}
\PYG{g+go}{        R\PYGZus{}A = 6374581.4671}
\PYG{g+go}{        a = 6378137.0}
\PYG{g+go}{        b = 6356752.31414}
\PYG{g+go}{        e = 0.0578063088401}
\PYG{g+go}{        f = 0.00335281068118}
\PYG{g+go}{        lat\PYGZus{}0 = \PYGZhy{}37}
\PYG{g+go}{        lon\PYGZus{}0 = 174}
\PYG{g+go}{        radians = False}
\PYG{g+go}{        sphere = False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Q3}
\end{Verbatim}


\subsection{Using the \texttt{distortion} Module}
\label{introduction:using-the-distortion-module}
The module \code{distortion} computes distortions of map projections created via \code{projection\_wrapper} and was used to produce the tables in {\hyperref[introduction:grs2013]{{[}GRS2013{]}}}.
The module is not necessary for manipulating the rHEALPix DGGS.

Import all the classes, methods, and constants from the module:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{distortion} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

Import the WGS84 ellipsoid, define the rHEALPix projection on the ellipsoid, and compute linear distortion and areal distortion for the projection at a given point:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}ELLIPSOID}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{projection\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{n}{Proj}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{E}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rhealpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{distortion}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{o}{*}\PYG{n}{p}\PYG{p}{)}  \PYG{c}{\PYGZsh{} First entry of output is f(*p))}
\PYG{g+go}{((0.0, 3748655.115049511), 6.976075406932126, 1.1295629192757011, 1.1780969079183845)}
\end{Verbatim}

Sample 100 random points from the WGS84 ellipsoid and compute the sample minimum, sample maximum, sample median, sample mean, and sample standard deviation of the linear and area distortion functions of the rHEALPix projection of those points:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sample} \PYG{o}{=} \PYG{p}{[}\PYG{n}{E}\PYG{o}{.}\PYG{n}{random\PYGZus{}point}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{distortion\PYGZus{}stats}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{sample}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}  
\PYG{g+go}{[[14.918, 13.82, 0.124, 48.086, 8.623], [1.345, 0.371, 1.002, 2.375, 1.163], [1.178, 0.0, 1.178, 1.178, 1.178]]}
\end{Verbatim}

Do the same for 100 points chosen at random from an rHEALPix DGGS dart cell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{rhealpix\PYGZus{}dggs} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cell} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sample} \PYG{o}{=} \PYG{p}{[}\PYG{n}{cell}\PYG{o}{.}\PYG{n}{random\PYGZus{}point}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{distortion\PYGZus{}stats}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{sample}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[[38.907, 6.044, 28.189, 48.963, 38.701], [2.013, 0.226, 1.644, 2.415, 1.991], [1.178, 0.0, 1.178, 1.178, 1.178]]}
\end{Verbatim}


\chapter{The projection\_tools Module}
\label{projection_tools::doc}\label{projection_tools:module-projection_tools}\label{projection_tools:the-projection-tools-module}\index{projection\_tools (module)}
This Python 3.3 module implements several helper functions for coding map projections.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2012-01-26: Refactored code from release 0.3.

\item {} 
AR, 2013-07-23: Ported to Python 3.3.

\end{itemize}

NOTE:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise.
\index{auth\_lat() (in module projection\_tools)}

\begin{fulllineitems}
\phantomsection\label{projection_tools:projection_tools.auth_lat}\pysiglinewithargsret{\code{projection\_tools.}\bfcode{auth\_lat}}{\emph{phi}, \emph{e}, \emph{inverse=False}, \emph{radians=False}}{}
Given a point of geographic latitude \emph{phi} on an ellipse of 
eccentricity \emph{e}, return the authalic latitude of the point.
If \emph{inverse} =True, then compute its inverse approximately.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{beta} \PYG{o}{=} \PYG{n}{auth\PYGZus{}lat}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{beta}
\PYG{g+go}{0.68951821243544043}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{auth\PYGZus{}lat}\PYG{p}{(}\PYG{n}{beta}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}
\PYG{g+go}{0.78512652358127166}
\PYG{g+go}{0.7853981633974483}
\end{Verbatim}

NOTES:

The power series approximation used for the inverse is
standard in cartography (PROJ.4 uses it, for instance)
and accurate for small eccentricities.

\end{fulllineitems}

\index{auth\_rad() (in module projection\_tools)}

\begin{fulllineitems}
\phantomsection\label{projection_tools:projection_tools.auth_rad}\pysiglinewithargsret{\code{projection\_tools.}\bfcode{auth\_rad}}{\emph{a}, \emph{e}, \emph{inverse=False}}{}
Return the radius of the authalic sphere of the ellipsoid with major
radius \emph{a} and eccentricity \emph{e}.
If \emph{inverse} = True, then return the major radius of the ellipsoid
with authalic radius \emph{a} and eccentricity \emph{e}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{auth\PYGZus{}rad}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}     
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{e}\PYG{p}{,} \PYG{n}{auth\PYGZus{}rad}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.25 0.98939325967}
\PYG{g+go}{0.1111111111111111 0.99793514743}
\PYG{g+go}{0.0625 0.999348236456}
\PYG{g+go}{0.04 0.999733212354}
\PYG{g+go}{0.027777777777777776 0.999871371052}
\PYG{g+go}{0.02040816326530612 0.999930576286}
\PYG{g+go}{0.015625 0.999959307081}
\PYG{g+go}{0.012345679012345678 0.999974596271}
\PYG{g+go}{0.01 0.999983332861}
\end{Verbatim}

\end{fulllineitems}

\index{wrap\_latitude() (in module projection\_tools)}

\begin{fulllineitems}
\phantomsection\label{projection_tools:projection_tools.wrap_latitude}\pysiglinewithargsret{\code{projection\_tools.}\bfcode{wrap\_latitude}}{\emph{phi}, \emph{radians=False}}{}
Given a point p on the unit circle at angle \emph{phi} from the positive x-axis,
if p lies in the right half of the circle, then return its angle that lies 
in the interval {[}-pi/2, pi/2{]}.
If p lies in the left half of the circle, then reflect it through the 
origin, and return the angle of the reflected point that lies in the 
interval {[}-pi/2, pi/2{]}.
If \emph{radians} = True, then \emph{phi} and the output are given in radians.
Otherwise, they are given in degrees.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{45.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}45.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{90.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}90.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{l+m+mi}{135}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}45.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{135}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{45.0}
\end{Verbatim}

\end{fulllineitems}

\index{wrap\_longitude() (in module projection\_tools)}

\begin{fulllineitems}
\phantomsection\label{projection_tools:projection_tools.wrap_longitude}\pysiglinewithargsret{\code{projection\_tools.}\bfcode{wrap\_longitude}}{\emph{lam}, \emph{radians=False}}{}
Given a point p on the unit circle at angle \emph{lam} from the positive 
x-axis, return its angle theta in the range -pi \textless{}= theta \textless{} pi.
If \emph{radians} = True, then \emph{lam} and the output are given in radians.
Otherwise, they are given in degrees.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}3.1415926535897931}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{185}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{175.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{180}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}180.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{l+m+mi}{185}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}175.0}
\end{Verbatim}

\end{fulllineitems}



\chapter{The pj\_healpix Module}
\label{pj_healpix:module-pj_healpix}\label{pj_healpix::doc}\label{pj_healpix:the-pj-healpix-module}\index{pj\_healpix (module)}
This Python 3.3 module implements the HEALPix map projection as described in {\hyperref[pj_healpix:caro2007]{{[}CaRo2007{]}}}.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2013-01-26: Refactored code from release 0.3.

\item {} 
AR, 2013-03-05: In in\_healpix\_image() increased eps to 1e-10 to decrease out-of-bounds errors i was getting when drawing figures.

\item {} 
AR, 2013-07-23: Ported to Python 3.3.

\end{itemize}

NOTE:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise. 
By `ellipsoid' below, i mean an oblate ellipsoid of revolution.
\index{healpix() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.healpix}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{healpix}}{\emph{a=1}, \emph{e=0}}{}
Return a function object that wraps the HEALPix projection and its inverse
of an ellipsoid with major radius \emph{a} and eccentricity \emph{e}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{healpix}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.57495135977821477, 2.1457476865731113)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{)} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{;} \PYG{k}{print}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
\PYG{g+go}{(0.57495135977821477, 2.1457476865731113)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(6.3611093629270335e\PYGZhy{}15, 59.999999999999986) (0, 60)}
\end{Verbatim}

OUTPUT:
\begin{itemize}
\item {} 
A function object of the form f(u, v, radians=False, inverse=False).

\end{itemize}

\end{fulllineitems}

\index{healpix\_diagram() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.healpix_diagram}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{healpix\_diagram}}{\emph{a=1}, \emph{e=0}, \emph{shade\_polar\_region=True}}{}
Return a Sage Graphics object diagramming the HEALPix projection
boundary and polar triangles for the ellipsoid with major radius \emph{a} 
and eccentricity \emph{e}.
Inessential graphics method.
Requires Sage graphics methods.

\end{fulllineitems}

\index{healpix\_ellipsoid() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.healpix_ellipsoid}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{healpix\_ellipsoid}}{\emph{lam}, \emph{phi}, \emph{e=0}}{}
Compute the signature functions of the HEALPix projection of an oblate
ellipsoid with eccentricity \emph{e} whose authalic sphere is the unit sphere.
Works when \emph{e} = 0 (spherical case) too.

INPUT:
\begin{itemize}
\item {} 
\emph{lam, phi} - Geodetic longitude-latitude coordinates in radians.
Assume -pi \textless{}= \emph{lam} \textless{} pi and -pi/2 \textless{}= \emph{phi} \textless{}= pi/2.

\item {} 
\emph{e} - Eccentricity of the oblate ellipsoid.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0, 0.51115723774642163)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0, 0.26848445085783679)}
\end{Verbatim}

\end{fulllineitems}

\index{healpix\_ellipsoid\_inverse() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.healpix_ellipsoid_inverse}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{healpix\_ellipsoid\_inverse}}{\emph{x}, \emph{y}, \emph{e=0}}{}
Compute the inverse of healpix\_ellipsoid().

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{healpix\PYGZus{}ellipsoid\PYGZus{}inverse}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(0, 0.44879895051282759) (0, 0.4487989505128276)}
\end{Verbatim}

\end{fulllineitems}

\index{healpix\_sphere() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.healpix_sphere}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{healpix\_sphere}}{\emph{lam}, \emph{phi}}{}
Compute the signature function of the HEALPix 
projection of the unit sphere.

INPUT:
\begin{itemize}
\item {} 
\emph{lam, phi} - Geodetic longitude-latitude coordinates in radians.
Assume -pi \textless{}= \emph{lam} \textless{} pi and -pi/2 \textless{}= \emph{phi} \textless{}= pi/2.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{healpix\PYGZus{}sphere}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{arcsin}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{healpix\_sphere\_inverse() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.healpix_sphere_inverse}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{healpix\_sphere\_inverse}}{\emph{x}, \emph{y}}{}
Compute the inverse of the healpix\_sphere().

INPUT:
\begin{itemize}
\item {} 
\emph{x, y} - Planar coordinates in meters in the image of the
HEALPix projection of the unit sphere.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{healpix\PYGZus{}sphere\PYGZus{}inverse}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{arcsin}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{healpix\_vertices() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.healpix_vertices}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{healpix\_vertices}}{}{}
Return a list of the planar vertices of the HEALPix projection of 
the unit sphere.

\end{fulllineitems}

\index{in\_healpix\_image() (in module pj\_healpix)}

\begin{fulllineitems}
\phantomsection\label{pj_healpix:pj_healpix.in_healpix_image}\pysiglinewithargsret{\code{pj\_healpix.}\bfcode{in\_healpix\_image}}{\emph{x}, \emph{y}}{}
Return True if and only if \emph{(x, y)} lies in the image of the HEALPix 
projection of the unit sphere.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eps} \PYG{o}{=} \PYG{l+m+mi}{0}     \PYG{c}{\PYGZsh{} Test boundary points.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{hp} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{hp}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{in\PYGZus{}healpix\PYGZus{}image}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }            \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fail}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}healpix\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{in\PYGZus{}healpix\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

\end{fulllineitems}



\chapter{The pj\_rhealpix Module}
\label{pj_rhealpix:the-pj-rhealpix-module}\label{pj_rhealpix:module-pj_rhealpix}\label{pj_rhealpix::doc}\index{pj\_rhealpix (module)}
This Python 3.3 module implements the rHEALPix map projection.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2013-01-26: Refactored code from release 0.3.

\item {} 
AR, 2013-07-23: Ported to Python 3.3.

\end{itemize}

NOTE:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise. 
By `ellipsoid' below, i mean an oblate ellipsoid of revolution.
\index{combine\_triangles() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.combine_triangles}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{combine\_triangles}}{\emph{x}, \emph{y}, \emph{north\_square=0}, \emph{south\_square=0}, \emph{inverse=False}}{}
Rearrange point \emph{(x, y)} in the HEALPix projection by 
combining the polar triangles into two polar squares.
Put the north polar square in position \emph{north\_square} and 
the south polar square in position \emph{south\_square}.
If \emph{inverse} = True, uncombine the polar triangles.

INPUT:
\begin{itemize}
\item {} 
\emph{x, y} - Coordinates in the HEALPix projection of the unit sphere.

\item {} 
\emph{north\_square, south\_square} - Integers between 0 and 3 indicating 
the positions of the north\_square polar square and south\_square polar 
square respectively.
See rhealpix\_sphere() docstring for a diagram.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{u}\PYG{p}{,} \PYG{n}{v} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{combine\PYGZus{}triangles}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
\PYG{g+go}{(\PYGZhy{}1.8325957145940459, 1.5707963267948966)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{combine\PYGZus{}triangles}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}
\PYG{g+go}{(\PYGZhy{}0.78539816339744828, 1.0471975511965976)}
\PYG{g+go}{(\PYGZhy{}0.7853981633974483, 1.0471975511965976)}
\end{Verbatim}

\end{fulllineitems}

\index{in\_rhealpix\_image() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.in_rhealpix_image}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{in\_rhealpix\_image}}{\emph{x}, \emph{y}, \emph{north\_square=0}, \emph{south\_square=0}}{}
Return True if and only if the point \emph{(x, y)} lies in the image of 
the rHEALPix projection of the unit sphere.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eps} \PYG{o}{=} \PYG{l+m+mi}{0}     \PYG{c}{\PYGZsh{} Test boundary points.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{north\PYGZus{}square}\PYG{p}{,} \PYG{n}{south\PYGZus{}square} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rhp} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{north\PYGZus{}square}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{north\PYGZus{}square}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{north\PYGZus{}square} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{north\PYGZus{}square} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{south\PYGZus{}square} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{south\PYGZus{}square} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{south\PYGZus{}square}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{south\PYGZus{}square}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{eps}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{rhp}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{in\PYGZus{}rhealpix\PYGZus{}image}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }            \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fail}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{in\PYGZus{}rhealpix\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{in\PYGZus{}rhealpix\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.rhealpix}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{rhealpix}}{\emph{a=1}, \emph{e=0}, \emph{north\_square=0}, \emph{south\_square=0}}{}
Return a function object that wraps the rHEALPix projection and its inverse
of an ellipsoid with major radius \emph{a} and eccentricity \emph{e}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{rhealpix}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}0.57495135977821477, 2.1457476865731113)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{)} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{;} \PYG{k}{print}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}0.57495135977821477, 2.1457476865731113)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(6.3611093629270335e\PYGZhy{}15, 59.999999999999986) (0, 60)}
\end{Verbatim}

OUTPUT:
\begin{itemize}
\item {} 
A function object of the form f(u, v, radians=False, inverse=False).

\end{itemize}

\end{fulllineitems}

\index{rhealpix\_diagram() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.rhealpix_diagram}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{rhealpix\_diagram}}{\emph{a=1}, \emph{e=0}, \emph{north\_square=0}, \emph{south\_square=0}, \emph{shade\_polar\_region=True}}{}
Return a Sage Graphics object diagramming the rHEALPix projection
boundary and polar triangles for the ellipsoid with major radius \emph{a} 
and eccentricity \emph{e}.
Inessential graphics method.
Requires Sage graphics methods.

\end{fulllineitems}

\index{rhealpix\_ellipsoid() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.rhealpix_ellipsoid}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{rhealpix\_ellipsoid}}{\emph{lam}, \emph{phi}, \emph{e=0}, \emph{north\_square=0}, \emph{south\_square=0}}{}
Compute the signature functions of the rHEALPix map 
projection of an oblate ellipsoid with eccentricity \emph{e} whose 
authalic sphere is the unit sphere. 
The north polar square is put in position \emph{north\_square}, 
and the south polar square is put in position \emph{south\_square}.
Works when \emph{e} = 0 (spherical case) too.

INPUT:
\begin{itemize}
\item {} 
\emph{lam, phi} - Geographic longitude-latitude coordinates in radian.
Assume -pi \textless{}= \emph{lam} \textless{} pi and -pi/2 \textless{}= \emph{phi} \textless{}= pi/2.

\item {} 
\emph{e} - Eccentricity of the ellipsoid.

\item {} 
\emph{north\_square, south\_square} - (Optional; defaults = 0, 0) Integers 
between 0 and 3 indicating positions of north polar and 
south polar squares, respectively.
See rhealpix\_sphere() docstring for a diagram.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{arcsin}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rhealpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{arcsin}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0, 0.78539816339744828)}
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix\_ellipsoid\_inverse() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.rhealpix_ellipsoid_inverse}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{rhealpix\_ellipsoid\_inverse}}{\emph{x}, \emph{y}, \emph{e=0}, \emph{north\_square=0}, \emph{south\_square=0}}{}
Compute the inverse of rhealpix\_ellipsoid.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{rhealpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rhealpix\PYGZus{}ellipsoid\PYGZus{}inverse}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(2.2204460492503131e\PYGZhy{}16, 0.78539816339744806) (0, 0.7853981633974483)}
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix\_sphere() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.rhealpix_sphere}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{rhealpix\_sphere}}{\emph{lam}, \emph{phi}, \emph{north\_square=0}, \emph{south\_square=0}}{}
Compute the signature functions of the rHEALPix map projection of 
the unit sphere. 
The north polar square is put in position \emph{north\_square}, and the 
south polar square is put in position \emph{south\_square}.

INPUT:
\begin{itemize}
\item {} 
\emph{lam, phi} -Geographic longitude-latitude coordinates in radians.
Assume -pi \textless{}= \emph{lam} \textless{} pi and -pi/2 \textless{}= \emph{phi} \textless{}= pi/2.

\item {} 
\emph{north\_square, south\_square} - (Optional; defaults = 0, 0) Integers 
between 0 and 3 indicating positions of north polar and 
south polar squares, respectively.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rhealpix\PYGZus{}sphere}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}1.6199786334139372, 2.3070121835733044)}
\end{Verbatim}

NOTE:

The polar squares are labeled 0, 1, 2, 3 from east to west like this:

\begin{Verbatim}[commandchars=\\\{\}]
east         west        
*---*---*---*---*
\textbar{} 0 \textbar{} 1 \textbar{} 2 \textbar{} 3 \textbar{}
*---*---*---*---*
\textbar{}   \textbar{}   \textbar{}   \textbar{}   \textbar{}
*---*---*---*---*
\textbar{} 0 \textbar{} 1 \textbar{} 2 \textbar{} 3 \textbar{}
*---*---*---*---*
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix\_sphere\_inverse() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.rhealpix_sphere_inverse}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{rhealpix\_sphere\_inverse}}{\emph{x}, \emph{y}, \emph{north\_square=0}, \emph{south\_square=0}}{}
Compute the inverse of rhealpix\_sphere().

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{rhealpix\PYGZus{}sphere}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rhealpix\PYGZus{}sphere\PYGZus{}inverse}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(2.2204460492503131e\PYGZhy{}16, 0.78539816339744806) (0, 0.7853981633974483)}
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix\_vertices() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.rhealpix_vertices}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{rhealpix\_vertices}}{\emph{north\_square=0}, \emph{south\_square=0}}{}
Return a list of the planar vertices of the rHEALPix projection of 
the unit sphere.

\end{fulllineitems}

\index{triangle() (in module pj\_rhealpix)}

\begin{fulllineitems}
\phantomsection\label{pj_rhealpix:pj_rhealpix.triangle}\pysiglinewithargsret{\code{pj\_rhealpix.}\bfcode{triangle}}{\emph{x}, \emph{y}, \emph{north\_square=0}, \emph{south\_square=0}, \emph{inverse=False}}{}
Return the number of the polar triangle and region that \emph{(x, y)} lies in.
If \emph{inverse} = False, then assume \emph{(x,y)} lies in the image of the HEALPix 
projection of the unit sphere.
If \emph{inverse} = True, then assume \emph{(x,y)} lies in the image of the 
\emph{(north\_square, south\_square)}-rHEALPix projection of the unit sphere.

INPUT:
\begin{itemize}
\item {} 
\emph{x, y} - Coordinates in the HEALPix or rHEALPix (if \emph{inverse} = True) 
projection of the unit sphere.

\item {} 
\emph{north\_square, south\_square} - Integers between 0 and 3 indicating the 
positions of the north\_square pole square and south\_square pole square 
respectively.
See rhealpix\_sphere() docstring for a diagram.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

OUTPUT:

The pair (triangle\_number, region).
Here region equals `north\_polar' (polar), `south\_polar' (polar), or 
`equatorial', indicating where \emph{(x, y)} lies.
If region = `equatorial', then triangle\_number = None.
Suppose now that region != `equatorial'.
If \emph{inverse} = False, then triangle\_number is the number (0, 1, 2, or 3) of 
the HEALPix polar triangle Z that \emph{(x, y)} lies in.
If \emph{inverse} = True, then triangle\_number is the number (0, 1, 2, or 3) of 
the HEALPix polar triangle that \emph{(x, y)} will get moved into.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{triangle}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{g+go}{(1, \PYGZsq{}north\PYGZus{}polar\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{triangle}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(1, \PYGZsq{}north\PYGZus{}polar\PYGZsq{})}
\end{Verbatim}

NOTES:

In the HEALPix projection, the polar triangles are labeled 0--3 from 
east to west like this:

\begin{Verbatim}[commandchars=\\\{\}]
    *       *       *       *       
  * 0 *   * 1 *   * 2 *   * 3 *        
*-------*-------*-------*-------*
\textbar{}       \textbar{}       \textbar{}       \textbar{}       \textbar{}
\textbar{}       \textbar{}       \textbar{}       \textbar{}       \textbar{}
\textbar{}       \textbar{}       \textbar{}       \textbar{}       \textbar{}
*-------*-------*-------*-------*
  * 0 *   * 1 *   * 2 *   * 3 *
    *       *       *       *
\end{Verbatim}

In the rHEALPix projection these polar triangles get rearranged
into a square with the triangles numbered \emph{north\_square} and \emph{south\_square} 
remaining fixed.
For example, if \emph{north\_square} = 1 and \emph{south\_square} = 3, 
then the triangles get rearranged this way:

\begin{Verbatim}[commandchars=\\\{\}]
North polar square:     *-------*       
                        \textbar{} * 3 * \textbar{}    
                        \textbar{} 0 * 2 \textbar{}    
                        \textbar{} * 1 * \textbar{}    
                    ----*-------*----
                    
South polar square: ----*-------*----
                        \textbar{} * 3 * \textbar{}
                        \textbar{} 2 * 0 \textbar{}
                        \textbar{} * 1 * \textbar{}
                        *-------*
\end{Verbatim}

\end{fulllineitems}



\chapter{The ellipsoids Module}
\label{ellipsoids:the-ellipsoids-module}\label{ellipsoids::doc}\label{ellipsoids:module-ellipsoids}\index{ellipsoids (module)}
This Python 3.3 code implements ellipsoids of revolution.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2012-01-26: Refactored code from release 0.3.

\item {} 
AR, 2013-07-23: Ported to Python 3.3.

\end{itemize}

NOTE:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise.

By `ellipsoid' throughout, i mean an ellipsoid of revolution and \emph{not} a general (triaxial) ellipsoid.
Points lying on an ellipsoid are given in geodetic (longitude, latitude) coordinates.
\index{Ellipsoid (class in ellipsoids)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid}\pysiglinewithargsret{\strong{class }\code{ellipsoids.}\bfcode{Ellipsoid}}{\emph{R=None}, \emph{a=6378137.0}, \emph{b=None}, \emph{e=None}, \emph{f=0.003352810681182319}, \emph{lon\_0=0}, \emph{lat\_0=0}, \emph{radians=False}}{}
Bases: \code{object}

Represents an ellipsoid of revolution (possibly a sphere) with a 
geodetic longitude-latitude coordinate frame.

INSTANCE ATTRIBUTES:
\begin{itemize}
\item {} 
\emph{sphere} - True if the ellipsoid is a sphere, and False otherwise.

\item {} 
\emph{R} - The radius of the ellipsoid in meters, implying that it is a 
sphere.

\item {} 
\emph{a} - Major radius of the ellipsoid in meters.

\item {} 
\emph{b} - Minor radius of the ellipsoid in meters.

\item {} 
\emph{e} - Eccentricity of the ellipsoid.

\item {} 
\emph{f} - Flattening of the ellipsoid.

\item {} 
\emph{R\_A} - Authalic radius of the ellipsoid in meters.

\item {} 
\emph{lon\_0} - Central meridian.

\item {} 
\emph{lat\_0} - Latitude of origin.

\item {} 
\emph{radians} - If True, use angles measured in radians for all calculations.
Use degrees otherwise.

\item {} 
\emph{phi\_0} - The latitude separating the equatorial region and 
the north polar region in the context of the (r)HEALPix projection.

\end{itemize}

Except for phi\_0, these attribute names match the names of the 
\href{http://trac.osgeo.org/proj/wiki/GenParms}{PROJ.4 ellipsoid parameters}.
\index{get\_points() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.get_points}\pysiglinewithargsret{\bfcode{get\_points}}{\emph{filename}}{}
Return a list of longitude-latitude points contained in
the file with filename \emph{filename}.
Assume the file is a text file containing at most one     
longitude-latitude point per line with the coordinates separated by 
whitespace and angles given in degrees.

\end{fulllineitems}

\index{graticule() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.graticule}\pysiglinewithargsret{\bfcode{graticule}}{\emph{n=400}, \emph{spacing=None}}{}
Return a list of longitude-latitude points sampled from a 
longitude-latitude graticule on this ellipsoid with the given 
spacing between meridians and between parallels.
The number of points on longitude and latitude per pi radians is \emph{n}.
The spacing should be specified in the angle units used for this
ellipsoid.
If \emph{spacing=None}, then a default spacing of pi/16 radians will be set.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}SPHERE}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{E}\PYG{o}{.}\PYG{n}{graticule}\PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{400}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{25600}
\end{Verbatim}

\end{fulllineitems}

\index{lattice() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.lattice}\pysiglinewithargsret{\bfcode{lattice}}{\emph{n=90}}{}
Return a 2n x n square lattice of longitude-latitude points.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}SPHERE}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{E}\PYG{o}{.}\PYG{n}{lattice}\PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}150.0, \PYGZhy{}60.0)}
\PYG{g+go}{(\PYGZhy{}150.0, 0.0)}
\PYG{g+go}{(\PYGZhy{}150.0, 60.0)}
\PYG{g+go}{(\PYGZhy{}90.0, \PYGZhy{}60.0)}
\PYG{g+go}{(\PYGZhy{}90.0, 0.0)}
\PYG{g+go}{(\PYGZhy{}90.0, 60.0)}
\PYG{g+go}{(\PYGZhy{}30.0, \PYGZhy{}60.0)}
\PYG{g+go}{(\PYGZhy{}30.0, 0.0)}
\PYG{g+go}{(\PYGZhy{}30.0, 60.0)}
\PYG{g+go}{(30.0, \PYGZhy{}60.0)}
\PYG{g+go}{(30.0, 0.0)}
\PYG{g+go}{(30.0, 60.0)}
\PYG{g+go}{(90.0, \PYGZhy{}60.0)}
\PYG{g+go}{(90.0, 0.0)}
\PYG{g+go}{(90.0, 60.0)}
\PYG{g+go}{(150.0, \PYGZhy{}60.0)}
\PYG{g+go}{(150.0, 0.0)}
\PYG{g+go}{(150.0, 60.0)}
\end{Verbatim}

\end{fulllineitems}

\index{meridian() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.meridian}\pysiglinewithargsret{\bfcode{meridian}}{\emph{lam}, \emph{n=200}}{}
Return a list of \emph{n} equispaced longitude-latitude 
points lying along the meridian of longitude \emph{lam}.
Avoid the poles.

\end{fulllineitems}

\index{parallel() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.parallel}\pysiglinewithargsret{\bfcode{parallel}}{\emph{phi}, \emph{n=200}}{}
Return a list of \emph{2*n} equispaced longitude-latitude 
points lying along the parallel of latitude \emph{phi}.

\end{fulllineitems}

\index{pi() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.pi}\pysiglinewithargsret{\bfcode{pi}}{}{}
Return pi if \emph{self.radians} = True and 180 otherwise.

\end{fulllineitems}

\index{random\_point() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.random_point}\pysiglinewithargsret{\bfcode{random\_point}}{\emph{lam\_min=None}, \emph{lam\_max=None}, \emph{phi\_min=None}, \emph{phi\_max=None}}{}
Return a point (given in geodetic coordinates) sampled uniformly at
random from the section of this ellipsoid with longitude in the range
\emph{lam\_min \textless{}= lam \textless{} lam\_max} and latitude in the range 
\emph{phi\_min \textless{}= phi \textless{} phi\_max}.     
But avoid the poles.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}SPHERE}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{E}\PYG{o}{.}\PYG{n}{random\PYGZus{}point}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} 
\PYG{g+go}{(\PYGZhy{}1.0999574573422948, 0.21029104897701129)}
\end{Verbatim}

\end{fulllineitems}

\index{xyz() (ellipsoids.Ellipsoid method)}

\begin{fulllineitems}
\phantomsection\label{ellipsoids:ellipsoids.Ellipsoid.xyz}\pysiglinewithargsret{\bfcode{xyz}}{\emph{lam}, \emph{phi}}{}
Given a point on this ellipsoid with longitude-latitude coordinates 
\emph{(lam, phi)}, return the point's 3D rectangular coordinates.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}SPHERE}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{E}\PYG{o}{.}\PYG{n}{xyz}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.70710678118654757, 0.0, 0.70710678118654746)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{The projection\_wrapper Module}
\label{projection_wrapper:the-projection-wrapper-module}\label{projection_wrapper:module-projection_wrapper}\label{projection_wrapper::doc}\index{projection\_wrapper (module)}
This Python 3.3 module implements a wrapper for map projections.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2013-01-25: Refactored code from release 0.3.

\item {} 
AR, 2013-07-23: Ported to Python 3.3.

\end{itemize}

NOTE:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise. 
By `ellipsoid' below, i mean an oblate ellipsoid of revolution.
\index{Proj (class in projection\_wrapper)}

\begin{fulllineitems}
\phantomsection\label{projection_wrapper:projection_wrapper.Proj}\pysiglinewithargsret{\strong{class }\code{projection\_wrapper.}\bfcode{Proj}}{\emph{ellipsoid=\textless{}ellipsoids.Ellipsoid object at 0x10297f850\textgreater{}}, \emph{proj=None}, \emph{**kwargs}}{}
Bases: \code{object}

Represents a map projection of a given ellipsoid.

INSTANCE ATTRIBUTES:
\begin{itemize}
\item {} 
\emph{ellipsoid} - An ellipsoid (Ellipsoid instance) to project.

\item {} 
\emph{proj} - The name (string) of the map projection, either a valid PROJ.4 
projection name or a valid homemade projection name.

\item {} 
\emph{kwargs} - Keyword arguments (dictionary) needed for the projection's 
definition, but not for the definition of the ellipsoid.  For example, 
these could be \{`north\_square':1, `south\_square': 2\} for the rhealpix 
projection.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID}    
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}ELLIPSOID}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rhealpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.0, 3748655.1150495009)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}ELLIPSOID}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cea}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.0, 3180183.485774971)}
\end{Verbatim}

NOTES:

When accessing a homemade map projection assume that it can be called via
a function g(a, e), where a is the major radius of the ellipsoid to be 
projected and e is its eccentricity.
The output of g should be a function object of the form 
f(u, v, radians=False, inverse=False).
For example, see the healpix() function in \code{pj\_healpix.py}.

\end{fulllineitems}



\chapter{The rhealpix\_dggs Module}
\label{rhealpix_dggs:the-rhealpix-dggs-module}\label{rhealpix_dggs:module-rhealpix_dggs}\label{rhealpix_dggs::doc}\index{rhealpix\_dggs (module)}
This Python 3.3 module implements the rHEALPix discrete global grid system.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2012-11-12: Initial version based upon grids.py.

\item {} 
AR, 2012-12-10: Corrected centroid() and moved some methods from graphics.py to here.

\item {} 
AR, 2012-12-19: Tested all the methods and added examples.

\item {} 
AR, 2013-01-01: Added ellipsoidal functionality to neighbor() and neighbors().

\item {} 
AR, 2013-01-14: Added intersects\_meridian(), cell\_latitudes(), cells\_from\_meridian(), cells\_from\_parallel(), cells\_from\_region().

\item {} 
AR, 2013-01-16: Changed the string keyword `surface' to a boolean keyword `plane'.

\item {} 
AR, 2013-03-11: Added minimal\_cover(), boundary(), interior(), triangle(), nw\_vertex().

\item {} 
AR, 2013-03-14: Fixed bug in nw\_vertex().

\item {} 
AR, 2013-07-23: Ported to Python 3.3.

\end{itemize}

NOTES:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise.

By `ellipsoid' throughout, i mean an ellipsoid of revolution and \emph{not} a general (triaxial) ellipsoid.

Points lying on the plane are given in rectangular (horizontal, vertical) coordinates, and points lying on the ellipsoid are given in geodetic (longitude, latitude) coordinates unless indicated otherwise.

DGGS abbreviates `discrete global grid system'.

Except when manipulating positive integers, I avoid the modulo function `\%' 
and insted write everything in terms of `floor()'.
This is because Python interprets the sign of `\%' differently than
Java or C, and I don't want to confuse people who are translating this code
to those languages.

EXAMPLES:

Create the (1, 2)-rHEALPix DGGS with N\_side = 3 that is based on the WGS84 ellipsoid. Use degrees instead of the default radians for angular measurements

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}ELLIPSOID}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{E}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{N\PYGZus{}side}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{)}
\PYG{g+go}{rHEALPix DGGS:}
\PYG{g+go}{    N\PYGZus{}side = 3}
\PYG{g+go}{    north\PYGZus{}square = 1}
\PYG{g+go}{    south\PYGZus{}square = 2}
\PYG{g+go}{    max\PYGZus{}areal\PYGZus{}resolution = 1}
\PYG{g+go}{    max\PYGZus{}resolution = 15}
\PYG{g+go}{    ellipsoid:}
\PYG{g+go}{        R\PYGZus{}A = 6374581.4671}
\PYG{g+go}{        a = 6378137.0}
\PYG{g+go}{        b = 6356752.314140356}
\PYG{g+go}{        e = 0.0578063088401}
\PYG{g+go}{        f = 0.003352810681182319}
\PYG{g+go}{        lat\PYGZus{}0 = 0}
\PYG{g+go}{        lon\PYGZus{}0 = 0}
\PYG{g+go}{        radians = False}
\PYG{g+go}{        sphere = False}
\end{Verbatim}

Pick a (longitude-latitude) point on the ellipsoid and find the resolution 1 cell that contains it

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{;} \PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{N8}
\end{Verbatim}

Find the ellipsoidal (edge) neighbors of this cell

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)} 
\PYG{g+go}{east N5}
\PYG{g+go}{south\PYGZus{}east Q0}
\PYG{g+go}{south\PYGZus{}west P2}
\PYG{g+go}{west N7}
\end{Verbatim}

Find the planar (edge) neighbors of this cell

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{plane}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)} 
\PYG{g+go}{down P2}
\PYG{g+go}{left N7}
\PYG{g+go}{right Q0}
\PYG{g+go}{up N5}
\end{Verbatim}

Find all the resolution 1 cells intersecting the longitude-latitude aligned ellipsoidal quadrangle with given northwest and southeast corners

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nw} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{se} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cells} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nw}\PYG{p}{,} \PYG{n}{se}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{cells}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N8\PYGZsq{}, \PYGZsq{}N5\PYGZsq{}, \PYGZsq{}N2\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}Q0\PYGZsq{}, \PYGZsq{}Q1\PYGZsq{}, \PYGZsq{}Q2\PYGZsq{}, \PYGZsq{}R0\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}Q3\PYGZsq{}, \PYGZsq{}Q4\PYGZsq{}, \PYGZsq{}Q5\PYGZsq{}, \PYGZsq{}R3\PYGZsq{}]}
\end{Verbatim}

Compute the ellipsoidal nuclei of these cells

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{cells}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,} \PYG{n}{cell}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N8 (0.0, 58.470677829627363)}
\PYG{g+go}{N5 (45.000000000000036, 58.470677829627363)}
\PYG{g+go}{N2 (90.000000000000028, 58.470677829627355)}
\PYG{g+go}{Q0 (14.999999999999998, 26.438744923100096)}
\PYG{g+go}{Q1 (45.0, 26.438744923100096)}
\PYG{g+go}{Q2 (74.999999999999986, 26.438744923100096)}
\PYG{g+go}{R0 (105.00000000000001, 26.438744923100096)}
\PYG{g+go}{Q3 (14.999999999999998, 3.560649871414923e\PYGZhy{}15)}
\PYG{g+go}{Q4 (45.0, 3.560649871414923e\PYGZhy{}15)}
\PYG{g+go}{Q5 (74.999999999999986, 3.560649871414923e\PYGZhy{}15)}
\PYG{g+go}{R3 (105.00000000000001, 3.560649871414923e\PYGZhy{}15)}
\end{Verbatim}

Create the (0, 0)-rHEALPix DGGS with N\_side = 3 that is based on the WGS84 ellipsoid. Use degrees instead of the default radians for angular measurements
and orient the DGGS so that the planar origin (0, 0) is on Auckland, New Zealand

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{174}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{37}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Approximate Auckland lon\PYGZhy{}lat coordinates}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Ellipsoid}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}A}\PYG{p}{,} \PYG{n}{f}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}F}\PYG{p}{,} \PYG{n}{radians}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{lon\PYGZus{}0}\PYG{o}{=}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lat\PYGZus{}0}\PYG{o}{=}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{n}{N\PYGZus{}side}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{north\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{south\PYGZus{}square}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{)}
\PYG{g+go}{rHEALPix DGGS:}
\PYG{g+go}{    N\PYGZus{}side = 3}
\PYG{g+go}{    north\PYGZus{}square = 0}
\PYG{g+go}{    south\PYGZus{}square = 0}
\PYG{g+go}{    max\PYGZus{}areal\PYGZus{}resolution = 1}
\PYG{g+go}{    max\PYGZus{}resolution = 15}
\PYG{g+go}{    ellipsoid:}
\PYG{g+go}{        R\PYGZus{}A = 6374581.4671}
\PYG{g+go}{        a = 6378137.0}
\PYG{g+go}{        b = 6356752.314140356}
\PYG{g+go}{        e = 0.0578063088401}
\PYG{g+go}{        f = 0.003352810681182319}
\PYG{g+go}{        lat\PYGZus{}0 = \PYGZhy{}37}
\PYG{g+go}{        lon\PYGZus{}0 = 174}
\PYG{g+go}{        radians = False}
\PYG{g+go}{        sphere = False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Q3}
\end{Verbatim}
\index{Cell (class in rhealpix\_dggs)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell}\pysiglinewithargsret{\strong{class }\code{rhealpix\_dggs.}\bfcode{Cell}}{\emph{rdggs=\textless{}rhealpix\_dggs.RHEALPixDGGS object at 0x103b63a50\textgreater{}}, \emph{suid=None}, \emph{level\_order\_index=None}, \emph{post\_order\_index=None}}{}
Bases: \code{object}

Represents a cell of the planar or ellipsoidal rHEALPix grid hierarchies.
Cell identifiers are of the form (p\_0, p\_1,...,p\_l), where p\_0 is one of 
the characters `A', `B', `C', `D', `E', `F' and p\_i for i \textgreater{} 0 is one of
the integers 0, 1,..., N\_side**2 - 1, where N\_side is the instance 
attribute from RHEALPixDGGS (the number of children cells along a cell's
side).

INSTANCE ATTRIBUTES:
\begin{itemize}
\item {} 
\emph{rdggs} - The DGGS that the cell comes from.

\item {} 
\emph{ellipsoid} - The underlying ellipsoid of the DGGS.

\item {} 
\emph{N\_side} - The N\_side attribute of the DGGS

\item {} 
\emph{suid} - The cell's ID (tuple).  SUID = spatially unique identifier.
(`id' is a reserved word in Python)

\item {} 
\emph{resolution} - The cell's resolution (nonnegative integer).

\end{itemize}

NOTE:

Several Cell methods have the keyword argument `plane'.
Setting it to True indicates that all input and output points and cells are 
to be interpreted as lying in the planar DGGS.
Setting it to False indicates that they are to be interpreted as lying in 
the ellipsoidal DGGS.
\index{area() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.area}\pysiglinewithargsret{\bfcode{area}}{\emph{plane=True}}{}
Return the area of this cell.

\end{fulllineitems}

\index{boundary() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.boundary}\pysiglinewithargsret{\bfcode{boundary}}{\emph{n=2}, \emph{plane=True}, \emph{interior=False}}{}
Return a list of \emph{4*n - 4} boundary points of this cell, 
\emph{n} on each edge, where \emph{n} \textgreater{}= 2.  
List the points in clockwise order starting from the cell's upper left 
corner if \emph{plane} = True, or from the cell's northwest corner 
if \emph{plane} = False.

If \emph{n} = 2, then the output is the same as vertices().
If \emph{interior} = True, then push the boundary points slighly into the
interior of the cell, which is convenient for some graphics methods.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{boundary}\PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)} \PYG{o}{==} \PYG{n}{c}\PYG{o}{.}\PYG{n}{vertices}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{boundary}\PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}3.1415926535897931, 1.3089969389957472)}
\PYG{g+go}{(\PYGZhy{}2.8797932657906435, 1.3089969389957472)}
\PYG{g+go}{(\PYGZhy{}2.6179938779914944, 1.3089969389957472)}
\PYG{g+go}{(\PYGZhy{}2.6179938779914944, 1.0471975511965979)}
\PYG{g+go}{(\PYGZhy{}2.6179938779914944, 0.78539816339744839)}
\PYG{g+go}{(\PYGZhy{}2.879793265790644, 0.78539816339744839)}
\PYG{g+go}{(\PYGZhy{}3.1415926535897931, 0.78539816339744839)}
\PYG{g+go}{(\PYGZhy{}3.1415926535897931, 1.0471975511965979)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{boundary}\PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}180.0, 74.35752898700072)}
\PYG{g+go}{(\PYGZhy{}157.50000000000003, 58.413661903472082)}
\PYG{g+go}{(\PYGZhy{}150.0, 41.810314895778603)}
\PYG{g+go}{(\PYGZhy{}165.00000000000003, 41.810314895778603)}
\PYG{g+go}{(\PYGZhy{}180.0, 41.810314895778603)}
\PYG{g+go}{(165.0, 41.810314895778596)}
\PYG{g+go}{(149.99999999999997, 41.810314895778596)}
\PYG{g+go}{(157.49999999999997, 58.413661903472082)}
\end{Verbatim}

\end{fulllineitems}

\index{centroid() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.centroid}\pysiglinewithargsret{\bfcode{centroid}}{\emph{plane=True}}{}
Return the centroid of this planar or ellipsoidal cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{centroid} \PYG{o}{=} \PYG{n}{c}\PYG{o}{.}\PYG{n}{centroid}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nucleus} \PYG{o}{=} \PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{centroid} \PYG{o}{==} \PYG{n}{nucleus}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{color() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.color}\pysiglinewithargsret{\bfcode{color}}{\emph{saturation=0.5}}{}
Return a unique RGB color tuple for this cell.
Inessential graphics method.

\end{fulllineitems}

\index{contains() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.contains}\pysiglinewithargsret{\bfcode{contains}}{\emph{p}, \emph{plane=True}}{}
Return True if this cell contains point \emph{p}, and return False 
otherwise.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{Q44}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{contains}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{ellipsoidal\_shape() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.ellipsoidal_shape}\pysiglinewithargsret{\bfcode{ellipsoidal\_shape}}{}{}
Return the shape of this cell (`quad', `cap', `dart', or 
`skew\_quad') when viewed on the ellipsoid.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{Cell}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ellipsoidal\PYGZus{}shape}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{quad}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{Cell}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ellipsoidal\PYGZus{}shape}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{dart}
\end{Verbatim}

\end{fulllineitems}

\index{index() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.index}\pysiglinewithargsret{\bfcode{index}}{\emph{order='resolution'}}{}
Return the index of \emph{self} when it's ordered according to \emph{order}.
Here \emph{order} can be `resolution' (default) or `post'.        
Indices start at 0.
The empty cell has index None.

The ordering comes from the way of traversing the tree T 
of all cells defined as follows.
The root of T is a non-cell place holder. 
The children of the root are the cells A \textless{} B \textless{} ... \textless{} F.
The children of a cell in T with suid s are s0 \textless{} s1 \textless{} ... \textless{} sn,
where n = self.N\_side**2.

The level order index of a nonempty cell is its position 
(starting from 0) in the level order traversal of T starting at cell A.

The post order index of a nonempty cell is its position 
(starting from 0) in the post order traversal of T.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{resolution}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{post}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{2}
\end{Verbatim}

\end{fulllineitems}

\index{interior() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.interior}\pysiglinewithargsret{\bfcode{interior}}{\emph{n=2}, \emph{plane=True}, \emph{flatten=False}}{}
Return an \emph{n} x \emph{n} matrix of interior points of this cell.
If the cell is planar, space the interior points on a regular
square grid.
List the points in standard, row-major matrix order.
If the cell is ellipsoidal, project the matrix of points to the
ellipsoid (longitude-latitude points).  
If \emph{flatten} = True, then flatten the matrix into a one dimensional
array of pairs.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{interior}\PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{flatten}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(90.0, 41.810380145353903)}
\PYG{g+go}{(\PYGZhy{}180.0, 41.810380145353903)}
\PYG{g+go}{(\PYGZhy{}1.2722218725854067e\PYGZhy{}14, 41.810380145353903)}
\PYG{g+go}{(\PYGZhy{}90.0, 41.810380145353903)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{all}\PYG{p}{(}\PYG{p}{[}\PYG{n}{c}\PYG{o}{.}\PYG{n}{contains}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{interior}\PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{flatten}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{intersects\_meridian() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.intersects_meridian}\pysiglinewithargsret{\bfcode{intersects\_meridian}}{\emph{lam}}{}
Return True if this ellipsoidal cell's boundary intersects the 
meridian of longitude \emph{lam}, and return False otherwise.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{intersects\PYGZus{}meridian}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{intersects\PYGZus{}meridian}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

\end{fulllineitems}

\index{intersects\_parallel() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.intersects_parallel}\pysiglinewithargsret{\bfcode{intersects\_parallel}}{\emph{phi}}{}
Return True if this cell's boundary intersects the parallel of latitude
\emph{phi}, and return False otherwise.

\end{fulllineitems}

\index{neighbor() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.neighbor}\pysiglinewithargsret{\bfcode{neighbor}}{\emph{direction}, \emph{plane=True}}{}
Return this cell's (edge) neighbor in the given direction. 
If \emph{plane} = True, then the direction is one of the strings 
`up', `right', `down', `left', which indicates the desired neighbor
relative to x-y coordinates 
in the following planar neighbor diagram, (drawn for self.N\_side = 3) 
where \emph{self} is the middle cell

\begin{Verbatim}[commandchars=\\\{\}]
             up
           *-----*
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
     *-----*-----*-----*
     \textbar{}     \textbar{} 012 \textbar{}     \textbar{}
left \textbar{}     \textbar{} 345 \textbar{}     \textbar{} right 
     \textbar{}     \textbar{} 678 \textbar{}     \textbar{}
     *-----*-----*-----*
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
           *-----*
            down
\end{Verbatim}

If \emph{plane} = False, then the direction is relative to 
longitude-latitude coordinates and is one of the strings 
`west', `east', `north', `south' for a quad or skew quad cell; 
`west', `east', `southwest', `southeast' for a northern dart cell;
`west', `east', `northwest', `northeast' for a southern dart cell;
`south\_0', `south\_1', `south\_2', `south\_3' for a northern cap cell;
`north\_0', `north\_1', `north\_2', `north\_3' for a southern cap cell;
For a cap cell, neighbor directions are numbered in increasing  
longitude, so that the longitude of the (nucleus of) north\_0 is less 
than the longitude of north\_1 is less than the longitude of north\_2 is
less than the longitude of north\_3, and the longitude of the south\_0 is
less than the longitude of south\_1, etc.

The tricky part in the planar scenario is that the neighbor 
relationships of the six resolution 0 cells is determined by the 
positions of those cells on the surface of a cube, 
one cell on each face, and not on a plane.
So sometimes rotating cells is needed to compute neighbors.

Return None if the given direction is invalid for this cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbor}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{down}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N3}
\end{Verbatim}

\end{fulllineitems}

\index{neighbors() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.neighbors}\pysiglinewithargsret{\bfcode{neighbors}}{\emph{plane=True}}{}
Return this cell's planar or ellipsoidal (edge) neighbors
as a dictionary whose keys are the directions of the neighbors.
See neighbor() for a list of valid directions.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+go}{down N3}
\PYG{g+go}{left R0}
\PYG{g+go}{right N1}
\PYG{g+go}{up Q2}
\end{Verbatim}

\end{fulllineitems}

\index{nucleus() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.nucleus}\pysiglinewithargsret{\bfcode{nucleus}}{\emph{plane=True}}{}
Return the nucleus and vertices of this planar or ellipsoidal cell
in the order (nucleus, upper left corner, lower left corner, 
lower right corner, upper right corner) with reference to the 
planar cell.
The output for ellipsoidal cells is the projection onto the ellipsoid
of the output for planar cells.  In particular, while the 
nucleus of a planar cell is its centroid, the nucleus 
of an ellipsoidal cell is not its centroid.
To compute the centroid of a cell, use centroid() below.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}2.3561944901923448, 1.5707963267948966)}
\end{Verbatim}

\end{fulllineitems}

\index{nw\_vertex() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.nw_vertex}\pysiglinewithargsret{\bfcode{nw\_vertex}}{\emph{plane=True}}{}
If \emph{plane} = False, then return the northwest vertex of this
ellipsoidal cell.
If \emph{plane} = True, then return the projection onto the plane
of the ellipsoidal northwest vertex.
On quad cells and cap cells, this function returns the same output 
as ul\_vertex().
On skew quad cells and dart cells, this function returns output
different from ul\_vertex().

WARNING: The northwest vertex of a cell might not lie in the cell, 
because not all cells contain their boundary.
\begin{description}
\item[{EXAMPLES::}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} Quad cell.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}2225148.7007489, \PYGZhy{}556287.17518722452)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nw\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}2225148.7007489, \PYGZhy{}556287.17518722452)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Cap cell.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}16688615.255616743, \PYGZhy{}8344307.6278083706)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nw\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}16688615.255616743, \PYGZhy{}8344307.6278083706)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} Skew quad cell.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}16688615.255616743, 10569456.32855727)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nw\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}15576040.905242294, 10569456.32855727)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Skew quad cell.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}16688615.255616743, \PYGZhy{}9456881.9781828206)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nw\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}16688615.255616743, \PYGZhy{}10569456.32855727)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Dart cell.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}17801189.605991192, 8344307.6278083716)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nw\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}16688615.255616743, 8344307.6278083716)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Dart cell.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}17801189.605991192, \PYGZhy{}11682030.678931719)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nw\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}16688615.255616743, \PYGZhy{}12794605.029306168)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{predecessor() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.predecessor}\pysiglinewithargsret{\bfcode{predecessor}}{\emph{resolution=None}}{}
Return the greatest resolution \emph{resolution} cell less than \emph{self}.
Note: \emph{self} need not be a resolution \emph{resolution} cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N07}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N088}
\end{Verbatim}

\end{fulllineitems}

\index{random\_point() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.random_point}\pysiglinewithargsret{\bfcode{random\_point}}{\emph{plane=True}}{}
Return a random point in this cell.
If \emph{plane} = True, then choose the point from
the planar cell.
Otherwise, choose the point from the ellipsoidal cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{random\PYGZus{}point}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{)}  
\PYG{g+go}{(1.4840291937583836, 0.90042819146088571)}
\end{Verbatim}

\end{fulllineitems}

\index{region() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.region}\pysiglinewithargsret{\bfcode{region}}{}{}
Return the region of this cell: `equatorial', `north\_polar', or
`south\_polar'.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{Cell}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{region}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{equatorial}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{Cell}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{region}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{north\PYGZus{}polar}
\end{Verbatim}

\end{fulllineitems}

\index{rotate() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.rotate}\pysiglinewithargsret{\bfcode{rotate}}{\emph{quarter\_turns}}{}
Return the cell that is the result of rotating this cell's
resolution 0 supercell by \emph{quarter\_turns} quarter turns anticlockwise.
Used in neighbor().

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N0\PYGZsq{}, \PYGZsq{}N2\PYGZsq{}, \PYGZsq{}N8\PYGZsq{}, \PYGZsq{}N6\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{rotate\_entry() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.rotate_entry}\pysiglinewithargsret{\bfcode{rotate\_entry}}{\emph{x}, \emph{quarter\_turns}}{}
Let N = self.N\_side and rotate the N x N matrix of subcell numbers

\begin{Verbatim}[commandchars=\\\{\}]
0        1          ... N - 1
N        N+1        ... 2*N - 1
...
(N-1)*N  (N-1)*N+1  ... N**2-1
\end{Verbatim}

anticlockwise by \emph{quarter\_turns} quarter turns to obtain a
new table with entries f(0), f(1), ..., f(N**2 - 1) read from
left to right and top to bottom.
Given entry number \emph{x} in the original matrix, return \emph{f(x)}.
Used in rotate().

INPUT:
\begin{itemize}
\item {} 
\emph{x} - A letter from RHEALPixDGGS.cells0 or one of the integers
0, 1, ..., N**2 - 1.

\item {} 
\emph{quarter\_turns} - 0, 1, 2, or 3.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n}{c}\PYG{o}{.}\PYG{n}{rotate\PYGZus{}entry}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[0, 2, 8, 6]}
\end{Verbatim}

NOTES:

Operates on letters from RHEALPixDGGS.cells0 too.
They stay fixed under f.
Only depends on \emph{self} through \emph{self.N\_side}.

\end{fulllineitems}

\index{subcell() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.subcell}\pysiglinewithargsret{\bfcode{subcell}}{\emph{other}}{}
Subcell (subset) relation on cells.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{subcell}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{subcell}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

\end{fulllineitems}

\index{subcells() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.subcells}\pysiglinewithargsret{\bfcode{subcells}}{\emph{resolution=None}}{}
Generator function for the set of all resolution \emph{resolution} subcells 
of this cell.  
If \emph{resolution=None}, then return a generator function for the children
of this cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{subcells}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N0\PYGZsq{}, \PYGZsq{}N1\PYGZsq{}, \PYGZsq{}N2\PYGZsq{}, \PYGZsq{}N3\PYGZsq{}, \PYGZsq{}N4\PYGZsq{}, \PYGZsq{}N5\PYGZsq{}, \PYGZsq{}N6\PYGZsq{}, \PYGZsq{}N7\PYGZsq{}, \PYGZsq{}N8\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{successor() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.successor}\pysiglinewithargsret{\bfcode{successor}}{\emph{resolution=None}}{}
Return the least resolution \emph{resolution} cell greater than \emph{self}.
Note: \emph{self} need not be a resolution \emph{resolution} cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N83}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{O}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{O0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N830}
\end{Verbatim}

\end{fulllineitems}

\index{suid\_from\_index() (rhealpix\_dggs.Cell static method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.suid_from_index}\pysiglinewithargsret{\strong{static }\bfcode{suid\_from\_index}}{\emph{rdggs}, \emph{index}, \emph{order='resolution'}}{}
Return the suid of a cell from its index.
The index is according to the cell ordering \emph{order},
which can be `resolution' (default) or `post'.
See the \emph{index()} docstring for more details on orderings.
For internal use.

\end{fulllineitems}

\index{suid\_rowcol() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.suid_rowcol}\pysiglinewithargsret{\bfcode{suid\_rowcol}}{}{}
Return the pair of row- and column-suids of \emph{self}, each as tuples.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{rdggs}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rsuid}\PYG{p}{,} \PYG{n}{csuid} \PYG{o}{=} \PYG{n}{c}\PYG{o}{.}\PYG{n}{suid\PYGZus{}rowcol}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rsuid} \PYG{o}{==} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{csuid} \PYG{o}{==} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{ul\_vertex() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.ul_vertex}\pysiglinewithargsret{\bfcode{ul\_vertex}}{\emph{plane=True}}{}
If \emph{plane} = True, then return the upper left vertex of this 
planar cell.
If \emph{plane} = False, then return the projection onto the ellipsoid
of the planar upper left vertex.
Note that for polar cells, this projection is not necessarily the 
northwest vertex.
For the latter vertex use nw\_vertex().

WARNING: The upper left vertex of a cell might not lie in the cell, 
because not all cells contain their boundary.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{UNIT\PYGZus{}003}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{vertices() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.vertices}\pysiglinewithargsret{\bfcode{vertices}}{\emph{plane=True}, \emph{trim\_dart=False}}{}
If \emph{plane} = True, then assume this cell is planar and return 
its four vertices in the order (upper left corner, upper right corner, 
lower right corner, lower left corner).
If \emph{plane} = False, then assume this cell is ellipsoidal and return
the projection of the planar vertices in the order
(northwest, northeast, southeast, southwest).
If \emph{plane} = False, this cell is a dart cell, and 
\emph{trim\_dart} = True, then remove the one non-vertex point from
the output. (Dart cells only have three vertices.)

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{vertices}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}3.1415926535897931, 2.3561944901923448)}
\PYG{g+go}{(\PYGZhy{}1.5707963267948966, 2.3561944901923448)}
\PYG{g+go}{(\PYGZhy{}1.5707963267948966, 0.78539816339744828)}
\PYG{g+go}{(\PYGZhy{}3.1415926535897931, 0.78539816339744828)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{vertices}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(89.999999999999929, 74.39069094879062)}
\PYG{g+go}{(119.99999999999997, 41.87385774220941)}
\PYG{g+go}{(90.0, 41.87385774220941)}
\PYG{g+go}{(60.000000000000007, 41.87385774220941)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{vertices}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{trim\PYGZus{}dart}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(89.999999999999929, 74.39069094879062)}
\PYG{g+go}{(119.99999999999997, 41.87385774220941)}
\PYG{g+go}{(60.000000000000007, 41.87385774220941)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{vertices}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(149.99999999999997, \PYGZhy{}41.87385774220941)}
\PYG{g+go}{(\PYGZhy{}180.0, \PYGZhy{}41.87385774220941)}
\PYG{g+go}{(\PYGZhy{}150.0, \PYGZhy{}41.87385774220941)}
\PYG{g+go}{(\PYGZhy{}180.0, \PYGZhy{}74.390690948790649)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{vertices}\PYG{p}{(}\PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{trim\PYGZus{}dart}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+go}{(149.99999999999997, \PYGZhy{}41.87385774220941)}
\PYG{g+go}{(\PYGZhy{}150.0, \PYGZhy{}41.87385774220941)}
\PYG{g+go}{(\PYGZhy{}180.0, \PYGZhy{}74.390690948790649)}
\end{Verbatim}

\end{fulllineitems}

\index{width() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.width}\pysiglinewithargsret{\bfcode{width}}{\emph{plane=True}}{}
Return the width of this cell. 
If \emph{plane} = False, then return None, because ellipsoidal cells
don't have a fixed width.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{UNIT\PYGZus{}003}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{N8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{width}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{xy\_range() (rhealpix\_dggs.Cell method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.Cell.xy_range}\pysiglinewithargsret{\bfcode{xy\_range}}{}{}
Return the x- and y-coordinate extremes of the planar version of 
this cell in the format ((x\_min, x\_max), (y\_min, y\_max)).

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{xy\PYGZus{}range}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{RHEALPixDGGS (class in rhealpix\_dggs)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS}\pysiglinewithargsret{\strong{class }\code{rhealpix\_dggs.}\bfcode{RHEALPixDGGS}}{\emph{ellipsoid=\textless{}ellipsoids.Ellipsoid object at 0x10297f850\textgreater{}}, \emph{N\_side=3}, \emph{north\_square=0}, \emph{south\_square=0}, \emph{max\_areal\_resolution=1}}{}
Bases: \code{object}

Represents an rHEALPix DGGS on a given ellipsoid.

CLASS ATTRIBUTES:
\begin{itemize}
\item {} 
\emph{cells0} - A list of the resolution 0 cell IDs (strings).

\end{itemize}

INSTANCE ATTRIBUTES:
\begin{itemize}
\item {} 
\emph{ellipsoid} - The underlying ellipsoid (Ellipsoid instance).

\item {} 
\emph{N\_side} - An integer of size at least 2.
Each planar cell has N\_side x N\_side child cells.

\item {} 
\emph{(north\_square, south\_square)} - Integers between 0 and 3 indicating
the positions of north polar and south polar squares, respectively,
of the rHEALPix projection used.

\item {} 
\emph{max\_areal\_resolution} - An area measured in square meters that 
upper bounds the area of the smallest ellipsoidal grid cells.

\item {} 
\emph{max\_resolution} - A nonnegative integer that is the maximum grid 
resolution needed to have ellipsoidal cells of area at most
\emph{max\_areal\_resolution}.

\item {} 
\emph{child\_order} - A dictionary of the ordering (Morton order) of child
cells of a cell in terms of the row-column coordinates in the matrix
of child cells.  Child cell are numbered 0 to \emph{N\_side**2 -1} from
left to right and top to bottom.

\item {} 
\emph{ul\_vertex} - A dictionary with key-value pairs (c, (x, y)), where
c is an element of \emph{cells0} and (x, y) is the upper left corner point
of the resolution 0 planar cell c.

\item {} 
\emph{atomic\_neighbors} - A dictionary with key-value pairs 
(n, \{`up': a, `down': b, `left': c, `right': d\}),
where n, a, b, c, and d are elements of \emph{cells0} or 
\{0, 1, ..., \emph{N\_side**2 -1}\}. 
Describes the planar (edge) neighbors of cell0 letter / child cell number 
n.

\end{itemize}

NOTE:

Several RHEALPixDGGS methods have the keyword argument `plane'.
Setting it to True indicates that all input and output points and cells are 
interpreted as lying in the planar DGGS.
Setting it to False indicates that they are interpreted as lying in 
the ellipsoidal DGGS.
\index{cell() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cell}\pysiglinewithargsret{\bfcode{cell}}{\emph{suid=None}, \emph{level\_order\_index=None}, \emph{post\_order\_index=None}}{}
Return a cell (Cell instance) of this DGGS either from its ID or 
from its resolution and index.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{Cell}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{N45}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_area() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cell_area}\pysiglinewithargsret{\bfcode{cell\_area}}{\emph{resolution}, \emph{plane=True}}{}
Return the area of a planar or ellipsoidal cell at the given
resolution.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}area}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{a} \PYG{o}{==} \PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}area}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{8}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_from\_point() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cell_from_point}\pysiglinewithargsret{\bfcode{cell\_from\_point}}{\emph{resolution}, \emph{p}, \emph{plane=True}}{}
Return the resolution \emph{resolution} cell that contains the point \emph{p}.
If \emph{plane} = True, then \emph{p} and the output cell lie in the
planar DGGS.
Otherwise, \emph{p} and the output cell lie in the ellipsoidal DGGS.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{Q3}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_from\_region() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cell_from_region}\pysiglinewithargsret{\bfcode{cell\_from\_region}}{\emph{ul}, \emph{dr}, \emph{plane=True}}{}
Return the smallest planar or ellipsoidal cell wholly containing 
the region bounded by the axis-aligned rectangle with upper left 
and lower right vertices given by the the points \emph{ul} and \emph{dr}, 
respectively.  
If such as cell does not exist, then return None.
If \emph{plane} = True, then \emph{ul} and \emph{dr} and the returned cell
lie in the planar DGGS.
Otherwise, \emph{ul} and \emph{dr} and the returned cell lie in the ellipsoidal
DGGS.

To specify an ellipsoidal cap region, set \emph{ul} = (-pi, pi/2) and 
\emph{dr} = (-pi, phi) for a northern cap from latitudes pi/2 to phi, or 
set \emph{ul} = (-pi, phi) and \emph{dr} = (-pi, -pi/2) for a southern cap from 
latitudes phi to -pi/2. 
(As usual, if \emph{self.ellipsoid.radians} = False, 
then use degrees instead of radians when specifying ul and dr.)

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{Q3}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_latitudes() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cell_latitudes}\pysiglinewithargsret{\bfcode{cell\_latitudes}}{\emph{resolution}, \emph{phi\_min}, \emph{phi\_max}, \emph{nucleus=True}, \emph{plane=True}}{}
Return a list of every latitude phi whose parallel intersects
a resolution \emph{resolution} cell nucleus and satisfies 
\emph{phi\_min} \textless{} phi \textless{} \emph{phi\_max}.
If \emph{plane} = True, then use rHEALPix y-coordinates for \emph{phi\_min},
\emph{phi\_max}, and the result. Return the list in increasing order.
If \emph{nucleus} = False, then return a list of every latitude phi whose   
parallel intersects the north or south boundary of a resolution 
\emph{resolution} cell and that satisfies \emph{phi\_min} \textless{} phi \textless{} \emph{phi\_max}.

NOTE:

By convention, the pole latitudes pi/2 and -pi/2 (or their 
corresponding rHEALPix y-coordinates) will be excluded.

There are 2*self.N\_side**resolution - 1 nuclei
latitudes between the poles if self.N\_side is odd and 
2*self.N\_side**resolution if self.N\_side is even.
Consequently, there are 2*self.N\_side**resolution 
boundary latitudes between the poles if self.N\_side is odd and 
2*self.N\_side**resolution - 1 boundary latitudes if self.N\_side is
even.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{phi} \PYG{o+ow}{in} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}latitudes}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}1.020505844}
\PYG{g+go}{\PYGZhy{}0.461443149003}
\PYG{g+go}{\PYGZhy{}1.24290127534e\PYGZhy{}16}
\PYG{g+go}{0.461443149003}
\PYG{g+go}{1.020505844}
\PYG{g+go}{1.57079632679}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{phi} \PYG{o+ow}{in} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}latitudes}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{nucleus}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)} 
\PYG{g+go}{\PYGZhy{}1.29836248989}
\PYG{g+go}{\PYGZhy{}0.730836688113}
\PYG{g+go}{\PYGZhy{}0.224577156195}
\PYG{g+go}{0.224577156195}
\PYG{g+go}{0.730836688113}
\PYG{g+go}{1.29836248989}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_width() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cell_width}\pysiglinewithargsret{\bfcode{cell\_width}}{\emph{resolution}, \emph{plane=True}}{}
Return the width of a planar cell at the given resolution.
If \emph{plane} = False, then return None, 
because the ellipsoidal cells don't have constant width.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}width}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{==} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell\PYGZus{}width}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{==} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{cells0 (rhealpix\_dggs.RHEALPixDGGS attribute)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cells0}\pysigline{\bfcode{cells0}\strong{ = {[}'N', `O', `P', `Q', `R', `S'{]}}}
\end{fulllineitems}

\index{cells\_from\_meridian() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cells_from_meridian}\pysiglinewithargsret{\bfcode{cells\_from\_meridian}}{\emph{resolution}, \emph{lam}, \emph{phi\_min}, \emph{phi\_max}}{}
Return a list of the resolution \emph{resolution} cells that intersect
the meridian segment of longitude \emph{lam} whose least latitude is
\emph{phi\_min} and whose greatest latitude is \emph{phi\_max}.
Sort the cells from north to south and west to east in case
two cells with the same nucleus latitude intersect the
meridian.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cells} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}meridian}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{cells}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N4\PYGZsq{}, \PYGZsq{}N2\PYGZsq{}, \PYGZsq{}N1\PYGZsq{}, \PYGZsq{}Q0\PYGZsq{}, \PYGZsq{}Q3\PYGZsq{}, \PYGZsq{}Q6\PYGZsq{}, \PYGZsq{}S8\PYGZsq{}, \PYGZsq{}S7\PYGZsq{}, \PYGZsq{}S4\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{cells\_from\_parallel() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cells_from_parallel}\pysiglinewithargsret{\bfcode{cells\_from\_parallel}}{\emph{resolution}, \emph{phi}, \emph{lam\_min}, \emph{lam\_max}}{}
Return a list of the resolution \emph{resolution} cells that intersect
the parallel segment of latitude \emph{phi} whose least longitude is
\emph{lam\_min} and whose greatest longitude is \emph{lam\_max}.
Sort the list from west to east.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cells} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}parallel}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{cells}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N6\PYGZsq{}, \PYGZsq{}N7\PYGZsq{}, \PYGZsq{}N8\PYGZsq{}, \PYGZsq{}N5\PYGZsq{}, \PYGZsq{}N2\PYGZsq{}, \PYGZsq{}N1\PYGZsq{}, \PYGZsq{}N0\PYGZsq{}, \PYGZsq{}N3\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{cells\_from\_region() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.cells_from_region}\pysiglinewithargsret{\bfcode{cells\_from\_region}}{\emph{resolution}, \emph{ul}, \emph{dr}, \emph{plane=True}}{}
If \emph{plane} = True, then return a list of lists of resolution 
\emph{resolution} cells that cover the axis-aligned rectangle whose 
upper left and lower right vertices are the points \emph{ul} and \emph{dr}, 
respectively.  
In the output, sort each sublist of cells from left to right (in the 
planar DGGS) and sort the sublists from top to bottom.

If \emph{plane} = False, then return a list of lists of resolution 
\emph{resolution} 
cells that cover the longitude-latitude aligned ellipsoidal quadrangle  
whose northwest and southeast vertices are the points \emph{ul} and \emph{dr}, 
respectively. Defunct quads with \emph{ul} = (stuff, pi/2) or 
\emph{dr} = (stuff, -pi/2) also work 
(and rely on the fact that the north and south pole can both 
be specified by infinitely many longitudes).

To specify an ellipsoidal cap region, set \emph{ul} = (-pi, pi/2) and 
\emph{dr} = (-pi, phi) for a northern cap from latitudes pi/2 to phi, or 
set \emph{ul} = (-pi, phi) and \emph{dr} = (-pi, -pi/2) for a southern cap from 
latitudes phi to -pi/2. (As usual, if \emph{self.ellipsoid.radians} = False, 
then use degrees instead of radians when specifying ul and dr.)

In the output, sort each sublist of cells from west to east (in the 
ellipsoidal DGGS) and sort the sublists from north to south.

Return the empty list if if \emph{ul{[}0{]} \textgreater{} dr{[}0{]}} or \emph{ul{[}1{]} \textless{} dr{[}1{]}}.

NOTE:

If \emph{plane} = True, then the resulting list is a matrix, that is,
each sublist has the same length.  This is not necessarily so if
\emph{plane} = False; see the examples below.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{R\PYGZus{}A} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{ellipsoid}\PYG{o}{.}\PYG{n}{R\PYGZus{}A}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ul} \PYG{o}{=} \PYG{n}{R\PYGZus{}A}\PYG{o}{*}\PYG{n}{array}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dr} \PYG{o}{=} \PYG{n}{R\PYGZus{}A}\PYG{o}{*}\PYG{n}{array}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Rectangle }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ul}\PYG{p}{,} \PYG{n}{dr}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{M}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}P2\PYGZsq{}, \PYGZsq{}Q0\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}P5\PYGZsq{}, \PYGZsq{}Q3\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}P8\PYGZsq{}, \PYGZsq{}Q6\PYGZsq{}]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ul} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dr} \PYG{o}{=} \PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Quad }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ul}\PYG{p}{,} \PYG{n}{dr}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{M}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N2\PYGZsq{}, \PYGZsq{}N1\PYGZsq{}, \PYGZsq{}N0\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}Q0\PYGZsq{}, \PYGZsq{}Q1\PYGZsq{}, \PYGZsq{}Q2\PYGZsq{}, \PYGZsq{}R0\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}Q3\PYGZsq{}, \PYGZsq{}Q4\PYGZsq{}, \PYGZsq{}Q5\PYGZsq{}, \PYGZsq{}R3\PYGZsq{}]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ul} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dr} \PYG{o}{=} \PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Defunct quad / lune segment }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ul}\PYG{p}{,} \PYG{n}{dr}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{M}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}Q6\PYGZsq{}, \PYGZsq{}Q7\PYGZsq{}, \PYGZsq{}Q8\PYGZsq{}, \PYGZsq{}R6\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}S8\PYGZsq{}, \PYGZsq{}S7\PYGZsq{}, \PYGZsq{}S6\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}S4\PYGZsq{}]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ul} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dr} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Cap}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cells\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ul}\PYG{p}{,} \PYG{n}{dr}\PYG{p}{,} \PYG{n}{plane}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{M}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}O6\PYGZsq{}, \PYGZsq{}O7\PYGZsq{}, \PYGZsq{}O8\PYGZsq{}, \PYGZsq{}P6\PYGZsq{}, \PYGZsq{}P7\PYGZsq{}, \PYGZsq{}P8\PYGZsq{}, \PYGZsq{}Q6\PYGZsq{}, \PYGZsq{}Q7\PYGZsq{}, \PYGZsq{}Q8\PYGZsq{}, \PYGZsq{}R6\PYGZsq{}, \PYGZsq{}R7\PYGZsq{}, \PYGZsq{}R8\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}S0\PYGZsq{}, \PYGZsq{}S1\PYGZsq{}, \PYGZsq{}S2\PYGZsq{}, \PYGZsq{}S5\PYGZsq{}, \PYGZsq{}S8\PYGZsq{}, \PYGZsq{}S7\PYGZsq{}, \PYGZsq{}S6\PYGZsq{}, \PYGZsq{}S3\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}S4\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{combine\_triangles() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.combine_triangles}\pysiglinewithargsret{\bfcode{combine\_triangles}}{\emph{u}, \emph{v}, \emph{inverse=False}}{}
Return the combine\_triangles() transformation of the point \emph{(u, v)} 
(or its inverse if \emph{inverse} = True) appropriate to the underlying 
ellipsoid.
It maps the HEALPix projection to the rHEALPix projection.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{combine\PYGZus{}triangles}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.0, 0.0)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{combine\PYGZus{}triangles}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}2.3561944901923448, 1.5707963267948966)}
\end{Verbatim}

\end{fulllineitems}

\index{grid() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.grid}\pysiglinewithargsret{\bfcode{grid}}{\emph{resolution}}{}
Generator function for all the cells at resolution \emph{resolution}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{grid0} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{grid0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N\PYGZsq{}, \PYGZsq{}O\PYGZsq{}, \PYGZsq{}P\PYGZsq{}, \PYGZsq{}Q\PYGZsq{}, \PYGZsq{}R\PYGZsq{}, \PYGZsq{}S\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{healpix() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.healpix}\pysiglinewithargsret{\bfcode{healpix}}{\emph{u}, \emph{v}, \emph{inverse=False}}{}
Return the HEALPix projection of point \emph{(u, v)} (or its inverse if 
\emph{inverse} = True) appropriate to this rHEALPix DGGS.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{healpix}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}2.3561944901923448, 1.5707963267948966)}
\end{Verbatim}

NOTE:

Uses \code{pj\_healpix} instead of the PROJ.4 version of HEALPix.

\end{fulllineitems}

\index{interval() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.interval}\pysiglinewithargsret{\bfcode{interval}}{\emph{a}, \emph{b}}{}
Generator function for all the resolution 
\emph{max(a.resolution, b.resolution)} cells between cell 
\emph{a} and cell \emph{b} (inclusive and with respect to the     
postorder ordering on cells).
Note that \emph{a} and \emph{b} don't have to lie at the same resolution.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{interval}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N1\PYGZsq{}, \PYGZsq{}N2\PYGZsq{}, \PYGZsq{}N3\PYGZsq{}, \PYGZsq{}N4\PYGZsq{}, \PYGZsq{}N5\PYGZsq{}, \PYGZsq{}N6\PYGZsq{}, \PYGZsq{}N7\PYGZsq{}, \PYGZsq{}N8\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{minimal\_cover() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.minimal_cover}\pysiglinewithargsret{\bfcode{minimal\_cover}}{\emph{resolution}, \emph{points}, \emph{plane=True}}{}
Find the minimal set of resolution \emph{resolution} cells that covers
the list of points \emph{points}.
If \emph{plane} = True, then assume \emph{points} is a list of x-y 
coordinates in the planar DGGS.
If \emph{plane} = False, then assume \emph{points} is a list of 
longitude-latitude coordinates in the ellipsoidal DGGS.  
This method will be made redundant by standard GIS rasterization 
tools that implement the rHEALPix projection.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c1} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{points} \PYG{o}{=} \PYG{p}{[}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{cover} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{minimal\PYGZus{}cover}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,} \PYG{n}{points}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{cover}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}N\PYGZsq{}, \PYGZsq{}P\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}N0\PYGZsq{}, \PYGZsq{}P7\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}N02\PYGZsq{}, \PYGZsq{}P73\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}N021\PYGZsq{}, \PYGZsq{}P733\PYGZsq{}]}
\PYG{g+go}{[\PYGZsq{}N0214\PYGZsq{}, \PYGZsq{}P7334\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{num\_cells() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.num_cells}\pysiglinewithargsret{\bfcode{num\_cells}}{\emph{res\_1}, \emph{res\_2=None}, \emph{subcells=False}}{}
Return the number of cells of resolutions \emph{res\_1} to \emph{res\_2} 
(inclusive).
Assume \emph{res\_1 \textless{}= res\_2}.
If \emph{subcells} = True, then return the number of subcells at resolutions
\emph{res\_1} to \emph{res\_2} (inclusive) of a cell at resolution \emph{res\_1}.
If \emph{res\_2=None} and \emph{subcells=False, then return the number of
cells at resolution {}`res\_1}.
If \emph{res\_2=None} and \emph{subcells} = True, then return the number of
subcells from resolution \emph{res\_1} to resolution \emph{self.max\_resolution}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{60}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{subcells}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{231627523606480}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{subcells}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{subcells}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{10}
\end{Verbatim}

\end{fulllineitems}

\index{plot\_cells() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.plot_cells}\pysiglinewithargsret{\bfcode{plot\_cells}}{\emph{cells}, \emph{surface='plane'}, \emph{label=True}, \emph{fontsize=15}, \emph{saturation=0.5}}{}
Plot the given list of cells on the given surface. 
The cells should all come from the same rHEALPix DGGS.
Inessential graphics method.  
Requires Sage graphics methods.

INPUT:
\begin{itemize}
\item {} 
\emph{cells} - A list of cells from a common rHEALPix DGGS.

\item {} 
\emph{surface} - (Optional; default = `plane'). 
One of the strings `plane', `plane\_lonlat', `cube', or `ellipsoid'.
Surface to draw cells on.

\item {} 
\emph{label} - (Optional; default = True). If True, then label cells
with their names. If False, then don't.

\item {} 
\emph{saturation} - (Optional) Number between 0 and 1 indicating the
saturation value of the cell color.

\end{itemize}

\end{fulllineitems}

\index{random\_cell() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.random_cell}\pysiglinewithargsret{\bfcode{random\_cell}}{\emph{resolution=None}}{}
Return a cell of the given resolution chosen uniformly at random 
from all cells at that resolution.
If \emph{resolution=None}, then the cell resolution is first chosen 
uniformly at random from {[}0,..,self.max\_resolution{]}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{random\PYGZus{}cell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} 
\PYG{g+go}{S480586367780080}
\end{Verbatim}

\end{fulllineitems}

\index{random\_point() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.random_point}\pysiglinewithargsret{\bfcode{random\_point}}{\emph{plane=True}}{}
Return a point in this DGGS sampled uniformly at
random from the plane or from the ellipsoid.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{E}\PYG{o}{.}\PYG{n}{random\PYGZus{}point}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} 
\PYG{g+go}{(\PYGZhy{}1.0999574573422948, 0.21029104897701129)}
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.rhealpix}\pysiglinewithargsret{\bfcode{rhealpix}}{\emph{u}, \emph{v}, \emph{inverse=False}}{}
Return the rHEALPix projection of the point \emph{(u, v)} (or its inverse if 
\emph{inverse} = True) appropriate to this rHEALPix DGGS.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{rhealpix}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(\PYGZhy{}1.8582720066840039, 2.0687188103032375)}
\end{Verbatim}

NOTE:

Uses \code{pj\_rhealpix} instead of the PROJ.4 version of rHEALPix.

\end{fulllineitems}

\index{triangle() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.triangle}\pysiglinewithargsret{\bfcode{triangle}}{\emph{x}, \emph{y}, \emph{inverse=True}}{}
If \emph{inverse} = False, then assume \emph{(x,y)} lies in the image of the 
HEALPix projection that comes with this DGGS, and 
return the number of the HEALPix polar triangle (0, 1, 2, 3, or None)   
and the region (`north\_polar', `south\_polar', or `equatorial') that 
\emph{(x, y)} lies in. 
If \emph{inverse} = True, then assume \emph{(x, y)} lies in the image of
the rHEALPix projection that comes with this DGGS, map \emph{(x, y)}
to its HEALPix image (x', y'), and return the number of the HEALPix 
polar triangle and the region that (x', y') lies in. 
If \emph{(x, y)} lies in the equatorial region, then the triangle number 
returned is None.

OUTPUT:

The pair (triangle\_number, region).

NOTES:

This is a wrapper for pj\_rhealpix.triangle().

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{RHEALPixDGGS}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{triangle}\PYG{p}{(}\PYG{o}{*}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0, \PYGZsq{}north\PYGZus{}polar\PYGZsq{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{triangle}\PYG{p}{(}\PYG{o}{*}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(3, \PYGZsq{}north\PYGZus{}polar\PYGZsq{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{triangle}\PYG{p}{(}\PYG{o}{*}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(None, \PYGZsq{}equatorial\PYGZsq{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{triangle}\PYG{p}{(}\PYG{o}{*}\PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(1, \PYGZsq{}south\PYGZus{}polar\PYGZsq{})}
\end{Verbatim}

\end{fulllineitems}

\index{xyz() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.xyz}\pysiglinewithargsret{\bfcode{xyz}}{\emph{u}, \emph{v}, \emph{lonlat=False}}{}
Given a point \emph{(u, v)} in the planar image of the rHEALPix projection, 
project it back to the ellipsoid and return its 3D rectangular 
coordinates.
If \emph{lonlat} = True, then assume \emph{(u, v)} is a longitude-latitude
point.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{xyz}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{lonlat}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.70710678118654757, 0.0, 0.70710678118654746)}
\end{Verbatim}

\end{fulllineitems}

\index{xyz\_cube() (rhealpix\_dggs.RHEALPixDGGS method)}

\begin{fulllineitems}
\phantomsection\label{rhealpix_dggs:rhealpix_dggs.RHEALPixDGGS.xyz_cube}\pysiglinewithargsret{\bfcode{xyz\_cube}}{\emph{u}, \emph{v}, \emph{lonlat=False}}{}
Given a point \emph{(u, v)} in the planar version of this rHEALPix DGGS, 
fold the rHEALPix image into a cube centered at the origin, 
and return the resulting point's 3D rectangular coordinates.  
If \emph{lonlat} = True, then assume \emph{(u, v)} is a longitude-latitude
point.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rdggs} \PYG{o}{=} \PYG{n}{UNIT\PYGZus{}003}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rdggs}\PYG{o}{.}\PYG{n}{xyz\PYGZus{}cube}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(0.78539816339744828, 0.0, \PYGZhy{}0.78539816339744828)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{The distortion Module}
\label{distortion:module-distortion}\label{distortion::doc}\label{distortion:the-distortion-module}\index{distortion (module)}
This Python 3.3 module computes linear and areal distortion statistics of 
map projections.
It is used for analysis only and so is not essential to manipulating 
the rHEALPix discrete global grid system.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2012-10-01: Initial version.

\item {} 
AR, 2013-01-21: Wasn't working in degrees mode. Fixed that bug.

\item {} 
AR, 2013-07-23: Ported to Python 3.3.

\end{itemize}
\index{distortion() (in module distortion)}

\begin{fulllineitems}
\phantomsection\label{distortion:distortion.distortion}\pysiglinewithargsret{\code{distortion.}\bfcode{distortion}}{\emph{T}, \emph{lam}, \emph{phi}}{}
Return ((x, y), mad, ld, ad)
Here \emph{(x, y) = T(lam, phi)}, the image under the map projection \emph{T} 
(an projection\_tools.Proj or projection\_tools.Proj4 instance)
of the longitude-latitude point \emph{(lam, phi)};
mad = maximum angular distortion at (x, y) = 2*arcsin((A - B)/(A + B))
ld = linear distortion at (x, y) = A/B;
ad = areal distortion at (x, y) = AB;
A and B are the major and minor radii, respectively, of the Tissot ellipse 
at (x, y).

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{projection\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{n}{Proj}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{healpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{distortion}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{((0.0, 3748655.1150495009), 0.12175548293070705, 1.1295629172526771, 1.1780969100283296)}
\end{Verbatim}

\end{fulllineitems}

\index{distortion\_stats() (in module distortion)}

\begin{fulllineitems}
\phantomsection\label{distortion:distortion.distortion_stats}\pysiglinewithargsret{\code{distortion.}\bfcode{distortion\_stats}}{\emph{T}, \emph{sample}, \emph{round\_numbers=3}}{}
Return the sample minimum, sample maximum, sample median, sample mean, 
and sample standard deviation of the maximum angular distortion, linear 
distortion, and area distortion functions
for the map projection \emph{T} 
(an projection\_tools.Proj or projection\_tools.Proj4 instance)
of the list \emph{sample} of longitude-latitude 
points chosen from the surface \emph{T.ellipsoid}.
Most likely you will want sample to comprise points sampled uniformly 
at random from the surface of \emph{T.ellipsoid} (and not simply sampled 
uniformly at random from the rectangle (-pi, pi) x (-pi/2, pi/2)).

OUTPUT:

(distortions, stats), where
distortions is a list of distortion() outputs for each longitude-
latitude point sampled;
stats is the list of lists {[}maximum angular distortion stats, 
linear distortion stats, area distortion stats{]}, where each stats sublist 
is of the form {[}sample mean, sample standard deviation, sample minimum,
sample maximum, sample median{]}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{projection\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{n}{Proj}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{E}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{healpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sample} \PYG{o}{=} \PYG{p}{[}\PYG{n}{E}\PYG{o}{.}\PYG{n}{random\PYGZus{}point}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{distortion\PYGZus{}stats}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{sample}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}  
\PYG{g+go}{[[0.309, 0.238, 0.001, 0.838, 0.178], [1.41, 0.375, 1.001, 2.372, 1.195], [1.178, 0.0, 1.178, 1.178, 1.178]]}
\end{Verbatim}

\end{fulllineitems}

\index{fff\_coeffs() (in module distortion)}

\begin{fulllineitems}
\phantomsection\label{distortion:distortion.fff_coeffs}\pysiglinewithargsret{\code{distortion.}\bfcode{fff\_coeffs}}{\emph{T}, \emph{lam}, \emph{phi}}{}
Return numerical approximations of the \href{http://en.wikipedia.org/wiki/First\_fundamental\_form}{first fundamental form} coefficients
E, F, and G (in that order) of map projection \emph{T} 
(an projection\_tools.Proj or projection\_tools.Proj4 instance) at longitude \emph{lam} and 
latitude \emph{phi}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{projection\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{n}{Proj}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{healpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{fff\PYGZus{}coeffs}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(40635288880650.484, 0.0, 42251277118793.328)}
\end{Verbatim}

\end{fulllineitems}

\index{scale\_factors() (in module distortion)}

\begin{fulllineitems}
\phantomsection\label{distortion:distortion.scale_factors}\pysiglinewithargsret{\code{distortion.}\bfcode{scale\_factors}}{\emph{T}, \emph{lam}, \emph{phi}}{}
Return numerical approximations of the local scale factors s\_M, s\_P, and 
s\_A of the map projection \emph{T} 
(an projection\_tools.Proj or projection\_tools.Proj4 instance)
at longitude \emph{lam} and  latitude \emph{phi}, where 
s\_M is the local linear scale along meridians, 
s\_P is the local linear scale along parallels, and
s\_A is the local area scale. 
Also return theta (in radians), the angle between the vectors (delxdellam, delydellam)
and (delxdelphi, delydelphi).

OUTPUT:

(s\_M, s\_P, s\_A, theta)

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{projection\PYGZus{}wrapper} \PYG{k+kn}{import} \PYG{n}{Proj}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ellipsoids} \PYG{k+kn}{import} \PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Proj}\PYG{p}{(}\PYG{n}{ellipsoid}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}ELLIPSOID\PYGZus{}RADIANS}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{healpix}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{scale\PYGZus{}factors}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(1.0212575853790069, 1.1535746974071357, 1.1780969100283301, 1.5707963267948966)}
\end{Verbatim}

\end{fulllineitems}

\index{utm\_zone() (in module distortion)}

\begin{fulllineitems}
\phantomsection\label{distortion:distortion.utm_zone}\pysiglinewithargsret{\code{distortion.}\bfcode{utm\_zone}}{\emph{lam}, \emph{phi}}{}
Return the Universal Transverse Mercator zone and hemisphere for longitude
\emph{lam} and latitude \emph{phi} given in radians.
Based on the WGS84 ellipsoid.
Return None if \emph{phi} is out of bounds, that is, if \emph{phi} is greater than
84 degrees or less than 80 degrees.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{utm\PYGZus{}zone}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{84}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{180}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{31}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{utm\PYGZus{}zone}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{180}\PYG{p}{)}\PYG{p}{)} 
\PYG{g+go}{None}
\end{Verbatim}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}

\begin{thebibliography}{CaRo2007}
\bibitem[GRS2013]{GRS2013}{\phantomsection\label{introduction:grs2013} 
Robert Gibb, Alexander Raichev, Michael Speth, \href{http://code.scenzgrid.org/index.php/p/scenzgrid-py/source/tree/master/rHEALPixDGGS-0.5/docs/rhealpix\_dggs\_preprint.pdf}{The rHEALPix discrete global grid system}, in preparation, 2013.
}
\bibitem[CaRo2007]{CaRo2007}{\phantomsection\label{pj_healpix:caro2007} 
Mark R. Calabretta and Boudewijn F. Roukema, Mapping on the healpix grid, Monthly Notices of the Royal Astronomical Society 381 (2007), no. 2, 865--872.
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{d}
\item {\texttt{distortion}}, \pageref{distortion:module-distortion}
\indexspace
\bigletter{e}
\item {\texttt{ellipsoids}}, \pageref{ellipsoids:module-ellipsoids}
\indexspace
\bigletter{p}
\item {\texttt{pj\_healpix}}, \pageref{pj_healpix:module-pj_healpix}
\item {\texttt{pj\_rhealpix}}, \pageref{pj_rhealpix:module-pj_rhealpix}
\item {\texttt{projection\_tools}}, \pageref{projection_tools:module-projection_tools}
\item {\texttt{projection\_wrapper}}, \pageref{projection_wrapper:module-projection_wrapper}
\indexspace
\bigletter{r}
\item {\texttt{rhealpix\_dggs}}, \pageref{rhealpix_dggs:module-rhealpix_dggs}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
